#include "Constants.h"
#include "CutGenerator.h"
#include "roundEccSep.h"
#include "cycleElimSep.h"
#include<vector>
#include <algorithm>    // std::sort

#ifdef _WIN32
#include <hash_map>
#else
#include <ext/hash_map>
#endif
#include <map>
#include <assert.h>

#include "cmstDebug.h"

#include <math.h>

#define DEFAULT_CUT_BATCH     100

#define FRAC_DIFF_SET_ECC     0.2

//#define DEC_ECC_SET

//#define MAX_NUM_ARCS_SET

//#define PRINT_CUT


#ifndef max
#define max(a,b) (((a)>(b))?(a):(b))
#endif

const int MaxSepSetsRound = 5000;

const double EccSetConnectEps = 0.01;

// counter for the candidate sets of vertices generated by the heuristic separation of
// ECCs
extern int candidateCount;

ProbCharact::ProbCharact()
{
   has_root = -1;
   min_nonroot_indeg = -1;
   max_nonroot_indeg = -1;

   min_nonroot_outdeg = -1;
   max_nonroot_outdeg = -1;

   min_root_indeg = -1;
   max_root_indeg = -1;

   min_root_outdeg = -1;
   max_root_outdeg = -1;

   is_fcnf = -1;

   arcsin_equal_arcsout = -1;

}


CutGenerator::CutGenerator( InstanceInfo* instance )
{
   cutBatch = DEFAULT_CUT_BATCH;
   intEps = INTEPS;
   probType = PROB_FCNF_SS;
   probClass = PCLASS_UNKNOWN;
   maxCalls = 0;
   minSetSize = 0;
   instance_.demand = NULL;
   copyInstance( instance );
   nextEccVertex = 1;
}

CutGenerator::~CutGenerator()
{
   if (instance_.demand != NULL)
      delete [] instance_.demand;
}


bool CutGenerator::isExtCapCutValid( )
{
   if( probProperties.is_fcnf )
      return true;
   else
      return false;
}

bool CutGenerator::isExtCyElimValid( )
{
   if (probType >= PROB_PATH)
      return true;
   else
      return false;
}

void CutGenerator::copyInstance( InstanceInfo* instance )
{
   if (instance_.demand != NULL)
      delete [] instance_.demand;
   instance_.capacity = instance->capacity;
   instance_.numNodes = instance->numNodes;
   instance_.nrootbranches = instance->nrootbranches;
   instance_.demand = new int[instance_.numNodes];
   memcpy( instance_.demand, instance->demand,
         instance_.numNodes * sizeof(int) );
}


int CutGenerator::setProbClass( ProblemClass pClass )
{
   int rval = 0;

   switch( pClass )
   {
      case PCLASS_CVRP:
         probProperties.has_root = 1;
         probProperties.is_fcnf = 1;

         probProperties.max_nonroot_indeg = 1;
         probProperties.min_nonroot_indeg = 1;

         probProperties.max_nonroot_outdeg = 1;
         probProperties.min_nonroot_outdeg = 1;

         probProperties.max_root_indeg = instance_.nrootbranches;
         probProperties.min_root_indeg = instance_.nrootbranches;

         probProperties.max_root_outdeg = instance_.nrootbranches;
         probProperties.min_root_outdeg = instance_.nrootbranches;

         probProperties.arcsin_equal_arcsout = 1;

         break;


      case PCLASS_TDTSP:
         probProperties.has_root = 1;
         probProperties.is_fcnf = 1;

         probProperties.max_nonroot_indeg = 1;
         probProperties.min_nonroot_indeg = 1;

         probProperties.max_nonroot_outdeg = 1;
         probProperties.min_nonroot_outdeg = 1;

         probProperties.max_root_indeg = 1;
         probProperties.min_root_indeg = 1;

         probProperties.max_root_outdeg = 1;
         probProperties.min_root_outdeg = 1;

         probProperties.arcsin_equal_arcsout = 1;

         break;
      case PCLASS_SDVRP:
         rval = 1;
         CMST_IF_GOTO( rval, CLEANUP, ( "Unknown / not implemented problem class %d\n", pClass ) );

         break;
      default:
         rval = 1;
         CMST_IF_GOTO( rval, CLEANUP, ( "Unknown / not implemented problem class %d\n", pClass ) );
   }
CLEANUP:
   return rval;
}

double CutGenerator::computeActivity( Cut* cut )
{
   double lhs = 0.0;

   // calculate the left-hand side
   int i, j, d, a;
   for (a = 0; a < solution->numArcs; a++)
   {
      i = solution->arcs[a].i;
      j = solution->arcs[a].j;
      lhs += cut->GetArcCoeff(cut->data, i, j) * solution->arcs[a].value;
   }
   for (a = 0; a < solution->numArcsCap; a++)
   {
      i = solution->arcsCap[a].i;
      j = solution->arcsCap[a].j;
      d = solution->arcsCap[a].d;
      lhs += cut->GetArcCapCoeff(cut->data, i, j, d) *
            solution->arcsCap[a].value;
/*      double coeff = cut->GetArcCapCoeff(cut->data, i, j, d);
      double val = solution->arcsCap[a].value;
      if( fabs( coeff ) > 1.0e-6 )
         fprintf(stderr,"   x(%d,%d)^%d = %lf, ", i, j, d, val );*/
   }
   //fprintf(stderr,"\n");
   return lhs;
}

bool CutGenerator::isViolated( Cut* cut, double tolerance )
{
   double lhs = 0.0;

   // calculate the left-hand side
   lhs = computeActivity( cut );

   // fprintf(stderr,"lhs = %lf, rhs = %lf\n", lhs, cut->rhs );

   // return true if the violation is larger than the tolerance
   switch (cut->sense)
   {
   case '=':
      cut->violation = fabs(lhs - cut->rhs);
      return (cut->violation > tolerance);
   case '>':
      cut->violation = (cut->rhs - lhs);
      return (cut->violation > tolerance);
   case '<':
      cut->violation = (lhs - cut->rhs);
      return (cut->violation > tolerance);
   default:
      return false;
   }
}

/**========================================================================***
***      DATA STRUCTURES AND FUNCTIONS FOR DEGREE CUTS                     ***
***========================================================================**/
double InDegree_GetArcCoeff( void* data, int i, int j )
{
   InDegreeCutData* ddata = (InDegreeCutData*) data;
   if( j == ddata->vertex )
      return 1.0;
   else
      return 0.0;
}

double InDegree_GetArcCapCoeff( void* data, int i, int j, int d )
{
   return 0.0;
}

bool InDegree_IsEqual( void* data1, void* data2 )
{
   InDegreeCutData* ddata1 = (InDegreeCutData*) data1;
   InDegreeCutData* ddata2 = (InDegreeCutData*) data2;
   return ddata1->vertex == ddata2->vertex;
}

/**========================================================================***
***      DATA STRUCTURES AND FUNCTIONS FOR ArcFix CUTS                     ***
***========================================================================**/
double ArcFix_GetArcCoeff( void* data, int i, int j )
{
   ArcFixCutData* fdata = (ArcFixCutData*) data;
   if( ( j == fdata->j ) && ( i == fdata->i ) )
      return 1.0;
   else
      return 0.0;
}

double ArcFix_GetArcCapCoeff( void* data, int i, int j, int d )
{
   return 0.0;
}

bool ArcFix_IsEqual( void* data1, void* data2 )
{
   ArcFixCutData* fdata1 = (ArcFixCutData*) data1;
   ArcFixCutData* fdata2 = (ArcFixCutData*) data2;
   return ( ( fdata1->i == fdata2->i ) && (fdata1->j == fdata2->j ) );
}

/**========================================================================***
***      DATA STRUCTURES AND FUNCTIONS FOR EXTENDED CAPACITY CUTS (ECCs)   ***
***========================================================================**/

double ExtCC_GetArcCoeff( void* data, int i, int j )
{
   //ExtCCData* eccData = (ExtCCData*)data;
   return 0.0;
}

double ExtCC_GetArcCapCoeff( void* data, int i, int j, int d )
{
   ExtCCData* eccData = (ExtCCData*)data;

//   fprintf(stderr," i = %d, j = %d, S.size() = %d\n", i, j, eccData->S.size() );
   assert( eccData != NULL );
   assert( i < (int)eccData->S.size() );
   assert( j < (int)eccData->S.size() );
   assert( i >= 0 );
   assert( j >= 0 );

   if (d == AnyDemand)
   {

	  if ( eccData->S[j] != eccData->S[i] )
          return 1.0;
      else
          return 0.0;
   }

   if (d > eccData->capacity)
      return 0.0;
   if ( eccData->S[j] && !eccData->S[i] )
      return eccData->incapcoeff[d];
   else if( !eccData->S[j] && eccData->S[i] )
      return eccData->outcapcoeff[d];
   else
      return 0.0;
}

bool ExtCC_IsEqual( void* data1, void* data2 )
{
   ExtCCData* eccData1 = (ExtCCData*)data1;
   ExtCCData* eccData2 = (ExtCCData*)data2;
   unsigned int i;
   if (eccData1->weightS != eccData2->weightS)
      return false;
   if (eccData1->S.size() != eccData2->S.size())
      return false;
   for (i = 0; i < eccData1->S.size(); i++)
      if (eccData1->S[i] != eccData2->S[i])
         return false;
   if (eccData1->capacity != eccData2->capacity)
      return false;
   if (eccData1->incapcoeff.size() != eccData2->incapcoeff.size())
      return false;
   for (i = 0; i < eccData1->incapcoeff.size(); i++)
      if (eccData1->incapcoeff[i] != eccData2->incapcoeff[i])
         return false;
   if (eccData1->outcapcoeff.size() != eccData2->outcapcoeff.size())
      return false;
   for (i = 0; i < eccData1->outcapcoeff.size(); i++)
      if (eccData1->outcapcoeff[i] != eccData2->outcapcoeff[i])
         return false;
   return true;
}

void* ExtCC_CopyData( void* data )
{
   ExtCCData* eccData = (ExtCCData*)data;
   ExtCCData* copied = new ExtCCData;
   *copied = *eccData;
   return copied;
}

void ExtCC_DestroyData( void* data )
{
   ExtCCData* eccData = (ExtCCData*)data;
   delete eccData;
}

// data structure that uses a tree to implement a set of sets of vertices
struct SetsTree
{
   bool endSet;
   std::vector<SetsTree> vertex;

   SetsTree()
   {
      endSet = false; // an empty set of sets
   }

   // return true if the set "target" starting at position "pos" is found
   bool find( int pos, std::vector<bool>& target )
   {
      int i;
      for (i = pos; i < (int)target.size(); i++)
      {
         if (target[i]) break;
      }
      if (i == (int)target.size()) return endSet;
      if (vertex[i].vertex.size() == 0) return false;
      return vertex[i].find( i+1, target );
   }

   // add the set "added" starting at position "pos"
   void add( int pos, std::vector<bool>& added )
   {
      int i;
      for (i = pos; i < (int)added.size(); i++)
      {
         if (added[i]) break;
      }
      if (i == (int)added.size())
      {
         endSet = true;
         return;
      }
      if (vertex[i].vertex.size() == 0)
         vertex[i].vertex.resize( added.size() );
      vertex[i].add( i+1, added );
   }
};

void CutGenerator::extCapCutGenByHeur( CutList* cuts )
{
   int num = 0;
   int den = 0;
   int cap = instance_.capacity;
   int setCount = 0;  
   
	std::vector<std::vector<int> > populacao_indices_S;
	std::vector<int> populacao_a;
	std::vector<int> populacao_b;
	
	int nS = 0;

   // Create the symmetric adjacency lists of vertices
   std::vector< std::vector<int> > adjVertex( instance_.numNodes );
   std::vector< std::vector<double> > adjValue( instance_.numNodes );
   for (int k = 0; k < solution->numArcs; k++)
   {
      if (solution->arcs[k].value < EccSetConnectEps) continue;
      int l;
      int i = solution->arcs[k].i;
      int j = solution->arcs[k].j;
      if ((i == 0) || (j == 0)) continue;
      for (l = 0; l < (int)adjVertex[i].size(); l++)
         if (adjVertex[i][l] == j) break;
      if (l == (int)adjVertex[i].size())
      {
         adjVertex[i].push_back(j);
         adjValue[i].push_back(solution->arcs[k].value);
      }
      else
      {
         adjValue[i][l] += solution->arcs[k].value;
      }
      for (l = 0; l < (int)adjVertex[j].size(); l++)
         if (adjVertex[j][l] == i) break;
      if (l == (int)adjVertex[j].size())
      {
         adjVertex[j].push_back(i);
         adjValue[j].push_back(solution->arcs[k].value);
      }
      else
      {
         adjValue[j][l] += solution->arcs[k].value;
      }
   }

   // Create the adjacency lists of capacitated arcs
   std::vector< std::vector<int> > adjCapArcs( instance_.numNodes );
   for (int k = 0; k < solution->numArcsCap; k++)
   {
      int i = solution->arcsCap[k].i;
      int j = solution->arcsCap[k].j;
      adjCapArcs[i].push_back( k );
      adjCapArcs[j].push_back( k );
      //fprintf( stderr, "x(%d,%d,%d) = %lf\n", i, j, solution->arcsCap[k].d,
      //      solution->arcsCap[k].value );
   }

   // Created an empty set of sets
   SetsTree setOfSets;
   setOfSets.vertex.resize(instance_.numNodes);

   // for each starting vertex except the root
   for (int v = 1; v < instance_.numNodes; v++)
   {
      // initialize the set of vertices and the candidates to enter
      std::vector<bool> inSet( instance_.numNodes, false );
      inSet[nextEccVertex] = true;
      std::vector<int> vertexSet;
      vertexSet.push_back( nextEccVertex );
      std::vector<int> candidates = adjVertex[nextEccVertex];
      int lastVertex = nextEccVertex;
      int setDemand = instance_.demand[lastVertex];

      // initialize the maps of LHS increases for the ECCs
      RationalMap incBeforeMap;
      RationalMap incAfterMap;

      // loop increasing the set while possible
      for (;;)
      {
         // initialize the changes in the y and z variables
         YZChange chg;
         chg.prevSetDem = setDemand - instance_.demand[lastVertex];
         for (int k = 0; k < (int)adjCapArcs[lastVertex].size(); k++)
         {
            CUTS_ArcCapVariable ac = solution->arcsCap[adjCapArcs[lastVertex][k]];
            //fprintf( stderr, "updating with x(%d,%d,%d) = %lf\n", ac.i, ac.j,
            //      ac.d, ac.value );
            if (ac.i == lastVertex)
            {
               if (inSet[ac.j])
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( -ac.value );
               }
               else
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( ac.value );
               }
            }
            else if (ac.j == lastVertex)
            {
               if (inSet[ac.i])
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( -ac.value );
               }
               else
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( ac.value );
               }
            }
            else
            {
               fprintf( stderr, "ERROR: Arc (%d,%d,%d) is adjacent to %d.\n",
                     ac.i, ac.j, ac.d, lastVertex );
            }
         }

         // printf the set
         /*fprintf(stderr,"Set: S =" );
         for (int j = 0; j < (int)vertexSet.size(); j++)
            fprintf( stderr, " %d", vertexSet[j] );
         fprintf(stderr,"\n");*/

         // evaluate the cut for the current set
         RECC_DoRoundings(chg, incBeforeMap, incAfterMap, cap, setDemand, num,
               den);
		 //fprintf( stderr, "a= %d, b= %d (%lf)\n", num, den, num/(double)den );
         setCount++;
         if (genSingleECCCut( cuts, num, den, 0,
               &vertexSet[0], vertexSet.size(), ECC_VIOLATED_EPS ))
         {
#ifdef PRINT_CUT
             fprintf( stderr, "ECC %d: viol = %lf, r = %d/%d, dem = %d.\n  Set = { %d",
                  cuts->numCuts, cuts->cuts[cuts->numCuts-1].violation,
                  num, den, setDemand, vertexSet[0] );
            for (int i = 1; i < (int)vertexSet.size(); i++)
               fprintf( stderr, ", %d", vertexSet[i] );
            fprintf( stderr, "}\n" ); 	
#endif
			 
			std::vector<int> indices(instance_.numNodes);		
			for (int j = 0; j < (int)vertexSet.size(); j++) 
			{
				indices[vertexSet[j]] = 1;
			}
			populacao_indices_S.push_back(indices);
			populacao_a.push_back(num);
			populacao_b.push_back(den);

            if (cuts->numCuts >= cutBatch) 
			{				   
				double distancia = 0;

				for (int i=0;i<populacao_indices_S.size()-1;i++) 
				{
					for (int j=i+1;j<populacao_indices_S.size();j++) 
					{
						nS++;
						int a1 = populacao_a[i];
						int a2 = populacao_a[j];
						int b1 = populacao_b[i];
						int b2 = populacao_b[j];

						double dif_r = a1/(double)b1- a2/(double)b2;

						distancia += fabs(dif_r)*2;
						for (int k = 0;k<populacao_indices_S[i].size();k++) 
						{			
							if (populacao_indices_S[i][k] != populacao_indices_S[j][k]) 
							{
								distancia += 1;
							}
						}
					}
				}
				cuts->diversity = distancia/nS;
				
				return;
			}
         }

         // save the set as already evaluated
         setOfSets.add(0, inSet);

         // evaluate all candidate vertices to be inserted in the set
         int bestCand = 0;
         int bestPos = -1;
         double bestViol = -2.0 * (cap + vertexSet.size());
         for (int k = 0; k < (int)candidates.size(); k++)
         {
            // skip if the new set has already been generated
            int i = candidates[k];
            inSet[i] = true;
            if (setOfSets.find(0, inSet))
            {
               // printf the repeated set
               //fprintf(stderr,"Repeated Set: S =" );
               //for (int j = 0; j < (int)vertexSet.size(); j++)
               //   fprintf( stderr, " %d", vertexSet[j] );
               //fprintf(stderr," %d\n", i);

               inSet[i] = false;
               continue;
            }

            // evaluate the cut using the new set (and the same multiplier)
            setDemand += instance_.demand[i];
            vertexSet.push_back(i);
            genSingleECCCut( cuts, num, den, 0, &vertexSet[0],
                  vertexSet.size(), 1.1 ); // never keep this cut
            double viol = cuts->cuts[cuts->numCuts].violation;
            if (viol < 0.0)
            {
               viol = -2.0 * vertexSet.size();
               for (int kk = 0; kk < (int)adjVertex[i].size(); kk++)
               {
                  int ii = adjVertex[i][kk];
                  if (inSet[ii])
                  {
#ifdef MAX_NUM_ARCS_SET
                     viol += 1.0;
#else
                     viol += adjValue[i][kk];
#endif
                  }
               }
            }

            // check for the best candidate vertex
            //double viol = cuts->cuts[cuts->numCuts].violation /
            //      cuts->cuts[cuts->numCuts].rhs;
            if (viol > bestViol)
            {
               bestViol = viol;
               bestCand = i;
               bestPos = k;
            }

            // restore the set
            inSet[i] = false;
            setDemand -= instance_.demand[i];
            vertexSet.pop_back();
         }

         // stop if no valid candidate has been found
         if (bestCand == 0) break;

         //fprintf( stderr, "Inserting vertex %d. violation = %lf.\n", bestCand,
         //      bestViol );

         // update the set and the list of candidates
         if (bestPos < (int)candidates.size() - 1)
            candidates[bestPos] = candidates[candidates.size() - 1];
         candidates.pop_back();
         for (int k = 0; k < (int)adjVertex[bestCand].size(); k++)
         {
            int i = adjVertex[bestCand][k];
            if (!inSet[i])
            {
               int l;
               for (l = 0; l < (int)candidates.size(); l++)
                  if (candidates[l] == i) break;
               if (l == (int)candidates.size())
                  candidates.push_back(i);
            }
         }
         inSet[bestCand] = true;
         setDemand += instance_.demand[bestCand];
         vertexSet.push_back(bestCand);
         lastVertex = bestCand;
      }

#ifdef DEC_ECC_SET		

	// loop decreasing the set while possible
      for (;;)
      {
         // evaluate all candidate vertices to be removed from the set
         int bestCand = 0;
         int bestPos = -1;
         double bestViol = -2.0 * (cap + vertexSet.size());
         int aux = vertexSet[(int)vertexSet.size() - 1];
         for (int k = 0; k < (int)vertexSet.size(); k++)
         {
            // skip if the new set has already been generated
            int i = vertexSet[k];
            inSet[i] = false;
            if (setOfSets.find(0, inSet))
            {
               // printf the repeated set
               //fprintf(stderr,"Repeated Set: S =" );
               //for (int j = 0; j < (int)vertexSet.size(); j++)
               //   if (j != k)
               //      fprintf( stderr, " %d", vertexSet[j] );
               //fprintf(stderr,"\n", i);
				

               inSet[i] = true;
               continue;
            }

            // evaluate the cut using the new set (and the same multiplier)
            setDemand -= instance_.demand[i];
            if (k < (int)vertexSet.size() - 1)
               vertexSet[k] = aux;
            vertexSet.pop_back();
            genSingleECCCut( cuts, num, den, 0, &vertexSet[0],
                  vertexSet.size(), 1.1 ); // never keep this cut
            double viol = cuts->cuts[cuts->numCuts].violation;
            if (viol < 0.0)
            {
               viol = -1.0;
               for (int kk = 0; kk < (int)adjVertex[i].size(); kk++)
               {
                  int ii = adjVertex[i][kk];
                  if (inSet[ii])
                  {
#ifdef MAX_NUM_ARCS_SET
                     viol -= 1.0;
#else
                     viol -= adjValue[i][kk];
#endif
                  }
               }
            }

            // check for the best candidate vertex
            //double viol = cuts->cuts[cuts->numCuts].violation /
            //      cuts->cuts[cuts->numCuts].rhs;
            if (viol > bestViol)
            {
               bestViol = viol;
               bestCand = i;
               bestPos = k;
            }

            // restore the set
            inSet[i] = true;
            setDemand += instance_.demand[i];
            vertexSet.push_back(aux);
            vertexSet[k] = i;
         }
		 
	

         // stop if no valid candidate has been found
         if (bestCand == 0) break;

         //fprintf( stderr, "Inserting vertex %d. violation = %lf.\n", bestCand,
         //      bestViol );

         // update the set
         inSet[bestCand] = false;
         setDemand -= instance_.demand[bestCand];
         if (bestPos < (int)vertexSet.size() - 1)
            vertexSet[bestPos] = aux;
         vertexSet.pop_back();
         lastVertex = bestCand;

         // initialize the changes in the y and z variables
         YZChange chg;
         chg.prevSetDem = setDemand + instance_.demand[lastVertex];
         for (int k = 0; k < (int)adjCapArcs[lastVertex].size(); k++)
         {
            CUTS_ArcCapVariable ac = solution->arcsCap[adjCapArcs[lastVertex][k]];
            //fprintf( stderr, "updating with x(%d,%d,%d) = %lf\n", ac.i, ac.j,
            //      ac.d, ac.value );
            if (ac.i == lastVertex)
            {
               if (inSet[ac.j])
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( ac.value );
               }
               else
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( -ac.value );
               }
            }
            else if (ac.j == lastVertex)
            {
               if (inSet[ac.i])
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( ac.value );
               }
               else
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( -ac.value );
               }
            }
            else
            {
               fprintf( stderr, "ERROR: Arc (%d,%d,%d) is adjacent to %d.\n",
                     ac.i, ac.j, ac.d, lastVertex );
            }
         }

         // printf the set
         //fprintf(stderr,"Set: S =" );
         //for (int j = 0; j < (int)vertexSet.size(); j++)
         //   fprintf( stderr, " %d", vertexSet[j] );
         //fprintf(stderr,"\n");
		 
         // evaluate the cut for the current set
         RECC_DoRoundings(chg, incBeforeMap, incAfterMap, cap, setDemand, num,
               den);
         setCount++;
         if (genSingleECCCut( cuts, num, den, 0,
               &vertexSet[0], vertexSet.size(), ECC_VIOLATED_EPS ))
         {

            //fprintf( stderr, "ECC violation = %lf, r = %lf, dem = %d.\n",
            //      cuts->cuts[cuts->numCuts-1].violation,
            //      double(num)/double(den), setDemand );
            if (cuts->numCuts >= cutBatch) return;
         }

         // save the set as already evaluated
         setOfSets.add(0, inSet);
      }

#endif

      // change to the next starting vertex
      nextEccVertex++;
      if (nextEccVertex == instance_.numNodes)
         nextEccVertex = 1;
   }
   
	double distancia = 0;

	if (populacao_indices_S.size() > 2)
	{
		for (int i=0;i<populacao_indices_S.size()-1;i++) 
		{
			for (int j=i+1;j<populacao_indices_S.size();j++) 
			{
				nS++;
				int a1 = populacao_a[i];
				int a2 = populacao_a[j];
				int b1 = populacao_b[i];
				int b2 = populacao_b[j];

				double dif_r = a1/(double)b1- a2/(double)b2;

				distancia += fabs(dif_r)*2;
				for (int k = 0;k<populacao_indices_S[i].size();k++) 
				{			
					if (populacao_indices_S[i][k] != populacao_indices_S[j][k]) 
					{
						distancia += 1;
					}
				}
			}
		}
		cuts->diversity = distancia/nS;
	} else
	{
		cuts->diversity = 0;
	}

}


bool CutGenerator::genSingleECCCut( CutList* cuts, int num, int den,
      int subtr, int *SetList, int SetListSize, double minViolation)
{
   int i, d;
   int demand = 0;
   ExtCCData* auxdata = 0;
   double prevViol = 0.0;

   // update the previous violation if the set size of the previous cut is similar
   /*if (cuts->numCuts > 0)
      if (cuts->cuts[cuts->numCuts - 1].templabel[0] != '\0')
      {
         auxdata = (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
         int numCommon = 0;
         for (i = 0; i < SetListSize; i++)
            if (auxdata->S[SetList[i]] == 1) numCommon++;
         int setSize = 0;
         for (i = 0; i < (int)auxdata->S.size(); i++)
            setSize += auxdata->S[i];
         if (numCommon >= (1.0 - FRAC_DIFF_SET_ECC) * (setSize + SetListSize - numCommon))
            prevViol = cuts->cuts[cuts->numCuts - 1].violation;
      }*/

   // create data for the new constraint
   auxdata = new ExtCCData;
   auxdata->S.resize( instance_.numNodes, 0 );
   auxdata->capacity = instance_.capacity;

   // prepare the vector of coefficients by demand
   auxdata->incapcoeff.resize(instance_.capacity + 1);
   auxdata->outcapcoeff.resize(instance_.capacity + 1);

   // Calculate the set demand and initialize the set of vertices
   for (i = 0; i < SetListSize; i++)
   {
      auxdata->S[SetList[i]] = 1;
      demand += instance_.demand[SetList[i]];
   }
   auxdata->weightS = demand;

   // calculate the right-hand side
   //double rhs = (double)eccceil((long long)demand * (long long)num, den);
   double rhs = eccfrac((long long)demand * (long long)num, den);
   if (rhs > 0) rhs = 1.0 - rhs;

   double fCoeff, alpha;
   for (d = 0; d <= instance_.capacity; d++ )
   {
      int dd = d - subtr;

      // Set coefficients for variables entering S
      fCoeff = eccfrac((long long)dd * (long long)num, den);
      if( fCoeff == 0 )
      {
         //auxdata->incapcoeff[d] = double((long long)dd * (long long)num) / double(den);
         auxdata->incapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0; //eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den);
            auxdata->incapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->incapcoeff[d] = fCoeff/alpha - fCoeff;
      }


      // Set coefficients for variables leaving S
      fCoeff = eccfrac(-(long long)dd * (long long)num, den);
      if( fCoeff == 0 )
      {
         //auxdata->outcapcoeff[d] = (double)(-(long long)dd * (long long)num) / double(den);
         auxdata->outcapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0;// eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den);
            auxdata->outcapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->outcapcoeff[d] = fCoeff/alpha - fCoeff;

      }
   }

   // fill the cut fields
   cuts->cuts[cuts->numCuts].data = auxdata;
   cuts->cuts[cuts->numCuts].sense = '>';
   cuts->cuts[cuts->numCuts].rhs = rhs;
   cuts->cuts[cuts->numCuts].GetArcCoeff = ExtCC_GetArcCoeff;
   cuts->cuts[cuts->numCuts].GetArcCapCoeff = ExtCC_GetArcCapCoeff;
   cuts->cuts[cuts->numCuts].IsEqual = ExtCC_IsEqual;
   cuts->cuts[cuts->numCuts].CopyData = ExtCC_CopyData;
   cuts->cuts[cuts->numCuts].DestroyData = ExtCC_DestroyData;
   sprintf(cuts->cuts[cuts->numCuts].templabel, "HECC" );

   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
      if (prevViol > 0)
      {
         if (cuts->cuts[cuts->numCuts].violation > prevViol)
         {
            delete (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
            cuts->cuts[cuts->numCuts - 1] = cuts->cuts[cuts->numCuts];
            return true;
         }
         else
         {
            delete auxdata;
            return false;
         }
      }
      else
      {
         cuts->numCuts++;
         return true;
      }
   }
   else
   {
      delete auxdata;
      return false;
   }
}

double CutGenerator::eccfrac(long long num, int den )
{
   if(!den)
   {
      fprintf(stdout,"Error -> den = 0 in line %d of %s\n", __LINE__, __FILE__ );
      exit(1);
   }
   long long div = num / den;
   if( div * den == num )
      return 0.0;
   else
   {
      if( num > 0 )
         return (double)num/den-div;
      else
         return (double)num/den-div+1;
   }
}


int CutGenerator::eccceil(long long num, int den )
{
   if(!den)
   {
      fprintf(stdout,"Error -> den = 0 in line %d of %s\n", __LINE__, __FILE__ );
      exit(1);
   }
   long long div = num / den;
   if( div * den == num )
      return div;
   else
   {
      if( num > 0 )
         return div+1;
      else
         return div;
   }
}

/**========================================================***
***      FUNCTIONS FOR EXTENDED CYCLE ELIMINATION CUTS     ***
***========================================================**/

void* GenericCut_CopyData( void* data )
{
   GenericCutData* cutData = (GenericCutData*)data;
   GenericCutData* copied = new GenericCutData;
   *copied = *cutData;
   return copied;
}

bool GenericCut_IsEqual( void* data1, void* data2 )
{
   GenericCutData* cut1 = (GenericCutData*)data1;
   GenericCutData* cut2 = (GenericCutData*)data2;
   ArcCapCoeffHash::iterator it1;
   ArcCapCoeffHash::iterator it2;
   if( cut1->coeffs.size() != cut2->coeffs.size() )
      return false;
   for( it1 = cut1->coeffs.begin(); it1 != cut1->coeffs.end(); it1++ )
   {
      it2 = cut2->coeffs.find( (*it1).first );
      if( it2 == cut2->coeffs.end() )
         return false;
      if( fabs( (*it1).second - (*it2).second ) > 1e-6 )
         return false;
   }
   return true;
}

void GenericCut_AddCoeff( void* data, int i, int j, int d, double coeff )
{
   GenericCutData* cutData = (GenericCutData*)data;
   ArcCapCoeffHash::iterator it;
   ArcCapHashKey k;

   k.i = i;
   k.j = j;
   k.d = AnyDemand;
   cutData->coeffs[ k ] = 1.0;

   k.i = i;
   k.j = j;
   k.d = d;
   it = cutData->coeffs.find( k );
   if( it == cutData->coeffs.end() )
      cutData->coeffs[ k ] = coeff;
   else
      cutData->coeffs[ k ] += coeff;
}

double GenericCut_GetArcCoeff( void* data, int i, int j )
{
//   GenericCutData* cutData = (GenericCutData*)data;
   return 0.0;
}

double GenericCut_GetArcCapCoeff( void* data, int i, int j, int d )
{
   GenericCutData* cutData = (GenericCutData*)data;
   ArcCapCoeffHash::iterator it;
   ArcCapHashKey k;

   k.i = i;
   k.j = j;
   k.d = d;
   it = cutData->coeffs.find( k );
   if( it == cutData->coeffs.end() )
      return 0.0;
   else
      return (*it).second;
}

void GenericCut_DestroyData( void* data )
{
   GenericCutData* cutData = (GenericCutData*)data;
   delete cutData;
}

struct NodeCapGraph
{
   int i;
   int d;
   std::vector<int> adjArcs;   // indices of outgoing adjacent arcs
   std::vector<NodeCapGraph*> adjNodes; // corresponding adjacent nodes

   // auxiliary attributes
   NodeCapGraph* parent;   // current parent in the traversal tree
   double flow;            // total flow to pass further
   int nextArc;            // index of the next arc to pass flow through
   double remain;          // remaining flow to pass through "nextArc"
};

struct NodeCapHashKey
{
   int i;
   int d;
#ifdef _WIN32
   operator size_t() const
   {
      return (i + d*300);
   }
#endif
   bool operator< ( const NodeCapHashKey &node ) const
   {
      if (i != node.i) return (i < node.i);
      return (d < node.d);
   }
};

#ifndef _WIN32
struct eqNodeCapKey
{
   bool operator() ( const NodeCapHashKey &node1, const NodeCapHashKey &node2 ) const
   {
      return( (node1.i == node2.i) && (node1.d == node2.d) );
   }
};

struct hashNodeCapKey
{
   size_t operator() ( const NodeCapHashKey &node ) const
   {
      hash<int> H;
      return( H(node.i + node.d*1000) );
   }
};
#endif

#ifdef _WIN32
typedef hash_map< NodeCapHashKey, NodeCapGraph > NodeCapGraphHash;
#else
typedef hash_map< NodeCapHashKey, NodeCapGraph, hashNodeCapKey, eqNodeCapKey > NodeCapGraphHash;
#endif

void CutGenerator::extCyElimCutGenByHeur( CutList* cuts )
{
   NodeCapGraphHash graphHash;
   std::vector<NodeCapGraph*> rootNodes;
   std::vector< std::vector<bool> > sets;

   // build the adjacency list of existing nodes in the support graph
   for (int k = 0; k < solution->numArcsCap; k++)
   {
      // skip the arcs whose flows are too small
      if (solution->arcsCap[k].value < ECEC_VIOLATED_EPS) continue;

      // add the tail node to the hash table if necessary
      NodeCapHashKey node;
      node.i = solution->arcsCap[k].i;
      node.d = solution->arcsCap[k].d + instance_.demand[node.i];
      NodeCapGraphHash::iterator it = graphHash.find( node );
      if (it == graphHash.end())
      {
         NodeCapGraph nodeGr;
         nodeGr.i = node.i;
         nodeGr.d = node.d;
         nodeGr.parent = 0;
         nodeGr.flow = 0.0;
         nodeGr.nextArc = 0;
         nodeGr.remain = 0;
         graphHash[node] = nodeGr;

         // store the sources of flow (at the root node)
         if (node.i == 0)
            rootNodes.push_back( &graphHash[node] );
      }

      // add the arc to the adjacent list of the node
      NodeCapGraph* nodeGrPtr = &graphHash[node];
      nodeGrPtr->adjArcs.push_back(k);
      if (node.i == 0)
         nodeGrPtr->flow += solution->arcsCap[k].value;
      if (nodeGrPtr->adjArcs.size() == 1)
         nodeGrPtr->remain = solution->arcsCap[k].value;

      // add the head node to the hash table if necessary
      NodeCapHashKey node2;
      node2.i = solution->arcsCap[k].j;
      node2.d = solution->arcsCap[k].d;
      it = graphHash.find( node2 );
      if (it == graphHash.end())
      {
         NodeCapGraph nodeGr;
         nodeGr.i = node2.i;
         nodeGr.d = node2.d;
         nodeGr.parent = 0;
         nodeGr.flow = 0.0;
         nodeGr.nextArc = 0;
         nodeGr.remain = 0;
         graphHash[node2] = nodeGr;
      }
      //fprintf( stderr, " (%d,%d)->(%d,%d)", node.i, node.d, node2.i, node2.d );

      // add the arc to the adjacent list of the node
      nodeGrPtr->adjNodes.push_back( &graphHash[node2] );
   }
   //fprintf( stderr, "\n" );

   //fprintf( stderr, "Flow decomposition:\n" );
   for (int s = 0; s < (int)rootNodes.size(); s++)
   {
      NodeCapGraph* node = rootNodes[s];
      while (node != 0)
      {
         double flow = node->flow;
         NodeCapGraph* next = 0;

         // if no more flow to pass
         if (flow < ECEC_VIOLATED_EPS)
         {
            // go bach to the parent
            node = node->parent;
            continue;
         }

         // if no more space to pass flow
         if (node->nextArc >= (int)node->adjArcs.size())
         {
            // if at the root, check if the current path has cycles
            if ((node->i == 0) && (node->parent != 0))
            {
               //fprintf( stderr, "flow %g:", node->flow );
               node->flow = 0;
               flow = 0;

               // find cycles in the path
               std::vector<NodeCapGraph*> lastNodeVisit( instance_.numNodes,
                     (NodeCapGraph*)0 );
               next = node->parent;
               while (next->i != 0)
               {
                  // Add the cut if a cycle has been found
                  if ((lastNodeVisit[next->i] != 0) && (cuts->numCuts < cutBatch))
                  {
                     // build the node set
                     std::vector<int> nodeSet;
                     std::vector<bool> flagSet(instance_.numNodes, false);
                     nodeSet.push_back(0);
                     NodeCapGraph* start = lastNodeVisit[next->i]->parent;
                     while (start != next)
                     {
                        nodeSet.push_back(start->i);
                        flagSet[start->i] = true;
                        start = start->parent;
                     }

                     // check if the set has not been tested before
                     int t;
                     for (t = 0; t < (int)sets.size(); t++)
                     {
                        if (sets[t] == flagSet) break;
                     }
                     if (t >= (int)sets.size())
                     {
                        // save the current set
                        sets.push_back( flagSet );

                        // do the separation
                        std::vector<int> heads;
                        std::vector<int> tails;
                        std::vector<int> demands;
                        std::vector<double> coeffs;
                        std::vector<int> nodeDems(instance_.numNodes+1, 0);
                        for (int d = 1; d < instance_.numNodes; d++)
                           nodeDems[d] = instance_.demand[d];
                        ExtCycleEliminator cycleElim(solution, &nodeDems[0],
                                instance_.capacity, &nodeSet[0], nodeSet.size()-1);
                        if ( cycleElim.generateCut(heads, tails, demands, coeffs) )
                        {
                           // create the specific data for the generic cut
                           GenericCutData* auxdata = new GenericCutData;

                           // get the coefficients for the cut
                           int nvars = coeffs.size();
                           for( int j = 0; j < nvars; j++ )
                           {
                              GenericCut_AddCoeff( auxdata, tails[j], heads[j], demands[j],
                                    coeffs[j] );
                           }

                           // Add cut to the cut list
                           cuts->cuts[cuts->numCuts].data = auxdata;
                           cuts->cuts[cuts->numCuts].sense = '<';
                           cuts->cuts[cuts->numCuts].rhs = 0.0;
                           cuts->cuts[cuts->numCuts].GetArcCoeff = GenericCut_GetArcCoeff;
                           cuts->cuts[cuts->numCuts].GetArcCapCoeff = GenericCut_GetArcCapCoeff;
                           cuts->cuts[cuts->numCuts].IsEqual = GenericCut_IsEqual;
                           cuts->cuts[cuts->numCuts].CopyData = GenericCut_CopyData;
                           cuts->cuts[cuts->numCuts].DestroyData = GenericCut_DestroyData;
                           sprintf(cuts->cuts[cuts->numCuts].templabel, "ECEC" );

                           // Double check the cut violation
                           if ( isViolated(&cuts->cuts[cuts->numCuts], ECEC_VIOLATED_EPS) )
                           {
                              //fprintf( stderr, "Found ECEC with viol=%g\n",
                              //      cuts->cuts[cuts->numCuts].violation );
                              cuts->numCuts++;
                           }
                           else
                           {
                              // printf( "CUT NOT VIOLATED!!!\n" );
                              ResetCut( &( cuts->cuts[cuts->numCuts] ) );
                           }
                        }
                     }
                  } // end "add the cut..."

                  // save the last capacitated node where this node was visited
                  //fprintf( stderr, " %d", next->i );
                  lastNodeVisit[next->i] = next;
                  next = next->parent;
               }

               //fprintf( stderr, "\n" );
            }

            // go bach to the parent
            // -> since the search is depth-first, the flow that may eventually
            //    come back from the child node does not need to be re-sent
            //    through the same arc because there is no way out of it.
            //    Hence, node->remain and node->nextArc do not need to be restored.
            node = node->parent;
            if (node != 0) node->flow += flow;
            continue;
         }

         // pass the flow and go to the child node
         next = node->adjNodes[node->nextArc];
         if (flow > node->remain) flow = node->remain;
         node->flow -= flow;
         node->remain -= flow;
         if (node->remain < ECEC_VIOLATED_EPS)
         {
            node->nextArc++;
            if (node->nextArc < (int)node->adjArcs.size())
            {
               int k = node->adjArcs[node->nextArc];
               node->remain = solution->arcsCap[k].value;
            }
         }
         next->flow += flow;
         next->parent = node;
         node = next;
      }
   }
}

//classe criada por Daniel
class Arco
{
public:
	int i,j, d_i, d_j, d;
	double valor;

	Arco(int i_, int j_, int d_, int d_i_, int d_j_, double valor_)
	{
		i = i_;
		j = j_;
		d = d_;
		d_i = d_i_;
		d_j = d_j_;
		valor = valor_;
	}

	bool Compativel(Arco &par) {
		if (j==par.i)
		{
			if (d == (par.d - d_j) )
				return true;
		}
		else if (i==par.j)
		{
			if (par.d == (d - d_i) )
				return true;
		}	
		
		return false;		
	}

	bool operator < (const Arco &arco) const
	{
		return (d > arco.d); //invertido para ordenar por capacidade decrescente
    }
};



bool CutGenerator::genSingleTriCliqueCut( CutList* cuts, int S_i, int S_j, int S_k, double minViolation )
{
	
    // create the specific data for the generic cut
    GenericCutData* auxdata = new GenericCutData;

	//fprintf(stderr,"Processing TriClique Cuts...\n");  
	
	std::vector<Arco> V;

	for (int k = 0; k < solution->numArcsCap; k++)
	{
      int i = solution->arcsCap[k].j;
      int j = solution->arcsCap[k].i;
      int d = solution->arcsCap[k].d;

	  if ( ( (i == S_i) || (i == S_j) || (i == S_k) ) && ( (j == S_i) || (j == S_j) || (j == S_k) ) )
	  {
		  V.push_back(Arco(i, j, d, instance_.demand[i], instance_.demand[j], solution->arcsCap[k].value));
		  //fprintf(stderr,"Adicionando arco %d: x%d_%d_%d = %lg\t",
			//	k, i, j, d, solution->arcsCap[k].value);  // codigo por Daniel Dias em 17-04-2015
	  }
	}
	//fprintf(stderr,"\n");

	std::vector<std::vector<Arco> > CHAIN;
	bool newChain = true;

	for (int ii = 0; ii < V.size(); ii++)
	{
		newChain = true;
		for (int jj = 0; jj < CHAIN.size(); jj++)
		{
			for (int kk = 0; kk < CHAIN[jj].size(); kk++)
			{
				if (V[ii].Compativel(CHAIN[jj][kk]))
				{
					CHAIN[jj].push_back(V[ii]);
					newChain = false;
					break;
				}
			}
			if (!newChain)
				break;			
		}
		if (newChain)
		{
			std::vector<Arco> temp;
			temp.push_back(V[ii]);
			CHAIN.push_back(temp);
		}
	}
	
	for (int jj = 0; jj < (int)CHAIN.size(); jj++)
	{
		std::sort(CHAIN[jj].begin(),CHAIN[jj].end());

		if (CHAIN[jj].size() == 1)
		{
			GenericCut_AddCoeff( auxdata, CHAIN[jj][0].j , CHAIN[jj][0].i, CHAIN[jj][0].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][0].i ,CHAIN[jj][0].j, CHAIN[jj][0].d);
		} 
		else if (CHAIN[jj].size() == 2)
		{
			if (CHAIN[jj][0].valor > CHAIN[jj][1].valor)
			{
			GenericCut_AddCoeff( auxdata, CHAIN[jj][0].j , CHAIN[jj][0].i, CHAIN[jj][0].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][0].i ,CHAIN[jj][0].j, CHAIN[jj][0].d);
			}
			else
			{
				GenericCut_AddCoeff( auxdata, CHAIN[jj][1].j , CHAIN[jj][1].i, CHAIN[jj][1].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][1].i ,CHAIN[jj][1].j, CHAIN[jj][1].d);
			}				
		}
		else
		{
			if (CHAIN[jj][0].valor + CHAIN[jj][2].valor > CHAIN[jj][1].valor) 
			{
				GenericCut_AddCoeff( auxdata, CHAIN[jj][0].j , CHAIN[jj][0].i, CHAIN[jj][0].d, 1);
				GenericCut_AddCoeff( auxdata, CHAIN[jj][2].j , CHAIN[jj][2].i, CHAIN[jj][2].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][0].i ,CHAIN[jj][0].j, CHAIN[jj][0].d);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][2].i ,CHAIN[jj][2].j, CHAIN[jj][2].d);
			}
			else
			{
				GenericCut_AddCoeff( auxdata, CHAIN[jj][1].j , CHAIN[jj][1].i, CHAIN[jj][1].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][1].i ,CHAIN[jj][1].j, CHAIN[jj][1].d);
			}
		}
	}
	//fprintf(stderr,"\n");
	
	// Add cut to the cut list
    cuts->cuts[cuts->numCuts].data = auxdata;
    cuts->cuts[cuts->numCuts].sense = '<';
    cuts->cuts[cuts->numCuts].rhs = 1;
    cuts->cuts[cuts->numCuts].GetArcCoeff = GenericCut_GetArcCoeff;
    cuts->cuts[cuts->numCuts].GetArcCapCoeff = GenericCut_GetArcCapCoeff;
    cuts->cuts[cuts->numCuts].IsEqual = GenericCut_IsEqual;
    cuts->cuts[cuts->numCuts].CopyData = GenericCut_CopyData;
    cuts->cuts[cuts->numCuts].DestroyData = GenericCut_DestroyData;
    sprintf(cuts->cuts[cuts->numCuts].templabel, "ECEC" );
		
	double lhs = computeActivity( &cuts->cuts[cuts->numCuts] );

	//fprintf( stderr, "TCC %d: viol = %lf, lhs = %lf .\n",
    //              cuts->numCuts, cuts->cuts[cuts->numCuts].violation, lhs);


   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
		cuts->numCuts++;
		return true;      
   }
   else
   {
		delete auxdata;
		return false;
   }
}

bool CutGenerator::genGenericCliqueCut( CutList* cuts, std::vector<int> x_i, std::vector<int> x_j, std::vector<int> x_d, double minViolation )
{
	
    // create the specific data for the generic cut
    GenericCutData* auxdata = new GenericCutData;

	//fprintf(stderr,"Processing Generic Clique Cuts...\n");  
		
	
	for (int i = 0; i < (int)x_i.size(); i++)
	{
		GenericCut_AddCoeff( auxdata, x_j[i] , x_i[i], x_d[i], 1);
	}
	//fprintf(stderr,"\n");
	
	// Add cut to the cut list
    cuts->cuts[cuts->numCuts].data = auxdata;
    cuts->cuts[cuts->numCuts].sense = '<';
    cuts->cuts[cuts->numCuts].rhs = 1;
    cuts->cuts[cuts->numCuts].GetArcCoeff = GenericCut_GetArcCoeff;
    cuts->cuts[cuts->numCuts].GetArcCapCoeff = GenericCut_GetArcCapCoeff;
    cuts->cuts[cuts->numCuts].IsEqual = GenericCut_IsEqual;
    cuts->cuts[cuts->numCuts].CopyData = GenericCut_CopyData;
    cuts->cuts[cuts->numCuts].DestroyData = GenericCut_DestroyData;
    sprintf(cuts->cuts[cuts->numCuts].templabel, "ECEC" );
		
	double lhs = computeActivity( &cuts->cuts[cuts->numCuts] );

	//fprintf( stderr, "TCC %d: viol = %lf, lhs = %lf .\n",
    //              cuts->numCuts, cuts->cuts[cuts->numCuts].violation, lhs);


   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
		cuts->numCuts++;
		return true;      
   }
   else
   {
		delete auxdata;
		return false;
   }
}

bool CutGenerator::genSingleOECCut( CutList* cuts, int t, int m,								 
      int *SetList, int SetListSize, double minViolation )
{
   int i, d;
   int demand = 0;
   ExtCCData* auxdata = 0;

   // create data for the new constraint
   auxdata = new ExtCCData;
   auxdata->S.resize( instance_.numNodes, 0 );
   auxdata->capacity = instance_.capacity;

   // prepare the vector of coefficients by demand
   auxdata->incapcoeff.resize(instance_.capacity + 1, 0.0);
   auxdata->outcapcoeff.resize(instance_.capacity + 1, 0.0);

   // Calculate the set demand and initialize the set of vertices
   for (i = 0; i < SetListSize; i++)
   {
      auxdata->S[SetList[i]] = 1;
      demand += instance_.demand[SetList[i]];
   }
   auxdata->weightS = demand;

   // calculate the right-hand side
   double rhs = 2.0;

   //Y1
	for (d = t; d <= demand - t -(m-2)*(t-1); d++ )
		auxdata->incapcoeff[d] = 1.0;

	//Y2
	for (d = demand - t -(m-2)*(t-1) + 1; d <= instance_.capacity; d++ )
		auxdata->incapcoeff[d] = 2.0;

	//Z
	//int tz1 = demand - t;
	//int tz2 = instance_.capacity - demand + 2*t - 1;
	//int tz = tz1 > tz2 ? tz1 : tz2; 
	//for (d = tz; d < instance_.capacity; d++ )
	//	auxdata->outcapcoeff[d] = -1.0;
	

	// fill the cut fields
	cuts->cuts[cuts->numCuts].data = auxdata;
	cuts->cuts[cuts->numCuts].sense = '>';
	cuts->cuts[cuts->numCuts].rhs = rhs;
	cuts->cuts[cuts->numCuts].GetArcCoeff = ExtCC_GetArcCoeff;
	cuts->cuts[cuts->numCuts].GetArcCapCoeff = ExtCC_GetArcCapCoeff;
	cuts->cuts[cuts->numCuts].IsEqual = ExtCC_IsEqual;
	cuts->cuts[cuts->numCuts].CopyData = ExtCC_CopyData;
	cuts->cuts[cuts->numCuts].DestroyData = ExtCC_DestroyData;
	sprintf(cuts->cuts[cuts->numCuts].templabel, "HECC" );

   // Store the cut if violated
	if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
	{     
		cuts->numCuts++;
		return true;
	}
	else
	{
		delete auxdata;
		return false;
	}
}

bool CutGenerator::genSingleECCCut_s( CutList* cuts, int num, int den, int s_num,
      int subtr, int *SetList, int SetListSize, double minViolation)
{
   int i, d;
   int demand = 0;
   ExtCCData* auxdata = 0;
   double prevViol = 0.0;

   // update the previous violation if the set size of the previous cut is similar
   /*if (cuts->numCuts > 0)
      if (cuts->cuts[cuts->numCuts - 1].templabel[0] != '\0')
      {
         auxdata = (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
         int numCommon = 0;
         for (i = 0; i < SetListSize; i++)
            if (auxdata->S[SetList[i]] == 1) numCommon++;
         int setSize = 0;
         for (i = 0; i < (int)auxdata->S.size(); i++)
            setSize += auxdata->S[i];
         if (numCommon >= (1.0 - FRAC_DIFF_SET_ECC) * (setSize + SetListSize - numCommon))
            prevViol = cuts->cuts[cuts->numCuts - 1].violation;
      }*/

   // create data for the new constraint
   auxdata = new ExtCCData;
   auxdata->S.resize( instance_.numNodes, 0 );
   auxdata->capacity = instance_.capacity;

   // prepare the vector of coefficients by demand
   auxdata->incapcoeff.resize(instance_.capacity + 1);
   auxdata->outcapcoeff.resize(instance_.capacity + 1);

   // Calculate the set demand and initialize the set of vertices
   for (i = 0; i < SetListSize; i++)
   {
      auxdata->S[SetList[i]] = 1;
      demand += instance_.demand[SetList[i]];
   }
   auxdata->weightS = demand;

   // calculate the right-hand side
   //double rhs = (double)eccceil((long long)demand * (long long)num, den);
   double rhs = eccfrac((long long)demand * (long long)num, den);
   if (rhs > 0) rhs = 1.0 - rhs;

   double fCoeff, alpha;
   for (d = 0; d <= instance_.capacity; d++ )
   {
      int dd = d - subtr;

      // Set coefficients for variables entering S
      fCoeff = eccfrac((long long)dd * (long long)num + (long long)s_num, den);
      if( fCoeff == 0 )
      {
         //auxdata->incapcoeff[d] = double((long long)dd * (long long)num) / double(den);
         auxdata->incapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0; //eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den);
            auxdata->incapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->incapcoeff[d] = fCoeff/alpha - fCoeff;
      }


      // Set coefficients for variables leaving S
      fCoeff = eccfrac(-(long long)dd * (long long)num - s_num, den);
      if( fCoeff == 0 )
      {
         //auxdata->outcapcoeff[d] = (double)(-(long long)dd * (long long)num) / double(den);
         auxdata->outcapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0;// eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den);
            auxdata->outcapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->outcapcoeff[d] = fCoeff/alpha - fCoeff;

      }
   }

   // fill the cut fields
   cuts->cuts[cuts->numCuts].data = auxdata;
   cuts->cuts[cuts->numCuts].sense = '>';
   cuts->cuts[cuts->numCuts].rhs = rhs;
   cuts->cuts[cuts->numCuts].GetArcCoeff = ExtCC_GetArcCoeff;
   cuts->cuts[cuts->numCuts].GetArcCapCoeff = ExtCC_GetArcCapCoeff;
   cuts->cuts[cuts->numCuts].IsEqual = ExtCC_IsEqual;
   cuts->cuts[cuts->numCuts].CopyData = ExtCC_CopyData;
   cuts->cuts[cuts->numCuts].DestroyData = ExtCC_DestroyData;
   sprintf(cuts->cuts[cuts->numCuts].templabel, "HECC" );

   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
      if (prevViol > 0)
      {
         if (cuts->cuts[cuts->numCuts].violation > prevViol)
         {
            delete (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
            cuts->cuts[cuts->numCuts - 1] = cuts->cuts[cuts->numCuts];
            return true;
         }
         else
         {
            delete auxdata;
            return false;
         }
      }
      else
      {
         cuts->numCuts++;
         return true;
      }
   }
   else
   {	   
		fprintf( stderr, "\nError, invalid cut, viol:%f; a:%d; b:%d; snum:%d\nS: {",
			cuts->cuts[cuts->numCuts].violation, num, den, s_num );
		for (i = 0; i < SetListSize; i++)
		{
		fprintf( stderr, "%d ," ,
			SetList[i] );
		}
		fprintf( stderr, "}\n");


		delete auxdata;
		return false;
   }
}