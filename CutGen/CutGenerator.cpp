#include "Constants.h"
#include "CutGenerator.h"
#include "roundEccSep.h"
#include "cycleElimSep.h"
#include<vector>
#include<string>
#include <algorithm>    // std::sort


#include "OECCut.h"
#include "OECSet.h"
//To be replaced
#include "OECInstance.h"
#include "OECSolution.h"

#ifdef _WIN32
#include <hash_map>
#else
#include <ext/hash_map>
#endif
#include <map>
#include <assert.h>

#include "cmstDebug.h"

#include <math.h>

#define DEFAULT_CUT_BATCH     100

#define FRAC_DIFF_SET_ECC     0.2

//#define DEC_ECC_SET

//#define MAX_NUM_ARCS_SET

//#define PRINT_CUT


#ifndef max
#define max(a,b) (((a)>(b))?(a):(b))
#endif

const int MaxSepSetsRound = 5000;

const double EccSetConnectEps = 0.01;

// counter for the candidate sets of vertices generated by the heuristic separation of
// ECCs
extern int candidateCount;

ProbCharact::ProbCharact()
{
   has_root = -1;
   min_nonroot_indeg = -1;
   max_nonroot_indeg = -1;

   min_nonroot_outdeg = -1;
   max_nonroot_outdeg = -1;

   min_root_indeg = -1;
   max_root_indeg = -1;

   min_root_outdeg = -1;
   max_root_outdeg = -1;

   is_fcnf = -1;

   arcsin_equal_arcsout = -1;

}


CutGenerator::CutGenerator( InstanceInfo* instance )
{
   cutBatch = DEFAULT_CUT_BATCH;
   intEps = INTEPS;
   probType = PROB_FCNF_SS;
   probClass = PCLASS_UNKNOWN;
   maxCalls = 0;
   minSetSize = 0;
   instance_.demand = NULL;
   copyInstance( instance );
   nextEccVertex = 1;
}

CutGenerator::~CutGenerator()
{
   if (instance_.demand != NULL)
      delete [] instance_.demand;
}


bool CutGenerator::isExtCapCutValid( )
{
   if( probProperties.is_fcnf )
      return true;
   else
      return false;
}

bool CutGenerator::isExtCyElimValid( )
{
   if (probType >= PROB_PATH)
      return true;
   else
      return false;
}

void CutGenerator::copyInstance( InstanceInfo* instance )
{
   if (instance_.demand != NULL)
      delete [] instance_.demand;
   instance_.capacity = instance->capacity;
   instance_.numNodes = instance->numNodes;
   instance_.nrootbranches = instance->nrootbranches;
   instance_.demand = new int[instance_.numNodes];
   memcpy( instance_.demand, instance->demand,
         instance_.numNodes * sizeof(int) );
}


int CutGenerator::setProbClass( ProblemClass pClass )
{
   int rval = 0;

   switch( pClass )
   {
      case PCLASS_CVRP:
         probProperties.has_root = 1;
         probProperties.is_fcnf = 1;

         probProperties.max_nonroot_indeg = 1;
         probProperties.min_nonroot_indeg = 1;

         probProperties.max_nonroot_outdeg = 1;
         probProperties.min_nonroot_outdeg = 1;

         probProperties.max_root_indeg = instance_.nrootbranches;
         probProperties.min_root_indeg = instance_.nrootbranches;

         probProperties.max_root_outdeg = instance_.nrootbranches;
         probProperties.min_root_outdeg = instance_.nrootbranches;

         probProperties.arcsin_equal_arcsout = 1;

         break;


      case PCLASS_TDTSP:
         probProperties.has_root = 1;
         probProperties.is_fcnf = 1;

         probProperties.max_nonroot_indeg = 1;
         probProperties.min_nonroot_indeg = 1;

         probProperties.max_nonroot_outdeg = 1;
         probProperties.min_nonroot_outdeg = 1;

         probProperties.max_root_indeg = 1;
         probProperties.min_root_indeg = 1;

         probProperties.max_root_outdeg = 1;
         probProperties.min_root_outdeg = 1;

         probProperties.arcsin_equal_arcsout = 1;

         break;
      case PCLASS_SDVRP:
         rval = 1;
         CMST_IF_GOTO( rval, CLEANUP, ( "Unknown / not implemented problem class %d\n", pClass ) );

         break;
      default:
         rval = 1;
         CMST_IF_GOTO( rval, CLEANUP, ( "Unknown / not implemented problem class %d\n", pClass ) );
   }
CLEANUP:
   return rval;
}

double CutGenerator::computeActivity( Cut* cut )
{
   double lhs = 0.0;

   // calculate the left-hand side
   int i, j, d, a;
   for (a = 0; a < solution->numArcs; a++)
   {
      i = solution->arcs[a].i;
      j = solution->arcs[a].j;
      lhs += cut->GetArcCoeff(cut->data, i, j) * solution->arcs[a].value;
   }
   for (a = 0; a < solution->numArcsCap; a++)
   {
      i = solution->arcsCap[a].i;
      j = solution->arcsCap[a].j;
      d = solution->arcsCap[a].d;
      lhs += cut->GetArcCapCoeff(cut->data, i, j, d) *
            solution->arcsCap[a].value;
/*      double coeff = cut->GetArcCapCoeff(cut->data, i, j, d);
      double val = solution->arcsCap[a].value;
      if( fabs( coeff ) > 1.0e-6 )
         fprintf(stderr,"   x(%d,%d)^%d = %lf, ", i, j, d, val );*/
   }
   //fprintf(stderr,"\n");
   return lhs;
}

bool CutGenerator::isViolated( Cut* cut, double tolerance )
{
   double lhs = 0.0;

   // calculate the left-hand side
   lhs = computeActivity( cut );

   // fprintf(stderr,"lhs = %lf, rhs = %lf\n", lhs, cut->rhs );

   // return true if the violation is larger than the tolerance
   switch (cut->sense)
   {
   case '=':
      cut->violation = fabs(lhs - cut->rhs);
      return (cut->violation > tolerance);
   case '>':
      cut->violation = (cut->rhs - lhs);
      return (cut->violation > tolerance);
   case '<':
      cut->violation = (lhs - cut->rhs);
      return (cut->violation > tolerance);
   default:
      return false;
   }
}

/**========================================================================***
***      DATA STRUCTURES AND FUNCTIONS FOR DEGREE CUTS                     ***
***========================================================================**/
double InDegree_GetArcCoeff( void* data, int i, int j )
{
   InDegreeCutData* ddata = (InDegreeCutData*) data;
   if( j == ddata->vertex )
      return 1.0;
   else
      return 0.0;
}

double InDegree_GetArcCapCoeff( void* data, int i, int j, int d )
{
   return 0.0;
}

bool InDegree_IsEqual( void* data1, void* data2 )
{
   InDegreeCutData* ddata1 = (InDegreeCutData*) data1;
   InDegreeCutData* ddata2 = (InDegreeCutData*) data2;
   return ddata1->vertex == ddata2->vertex;
}

/**========================================================================***
***      DATA STRUCTURES AND FUNCTIONS FOR ArcFix CUTS                     ***
***========================================================================**/
double ArcFix_GetArcCoeff( void* data, int i, int j )
{
   ArcFixCutData* fdata = (ArcFixCutData*) data;
   if( ( j == fdata->j ) && ( i == fdata->i ) )
      return 1.0;
   else
      return 0.0;
}

double ArcFix_GetArcCapCoeff( void* data, int i, int j, int d )
{
   return 0.0;
}

bool ArcFix_IsEqual( void* data1, void* data2 )
{
   ArcFixCutData* fdata1 = (ArcFixCutData*) data1;
   ArcFixCutData* fdata2 = (ArcFixCutData*) data2;
   return ( ( fdata1->i == fdata2->i ) && (fdata1->j == fdata2->j ) );
}

/**========================================================================***
***      DATA STRUCTURES AND FUNCTIONS FOR EXTENDED CAPACITY CUTS (ECCs)   ***
***========================================================================**/

double ExtCC_GetArcCoeff( void* data, int i, int j )
{
   //ExtCCData* eccData = (ExtCCData*)data;
   return 0.0;
}

double ExtCC_GetArcCapCoeff( void* data, int i, int j, int d )
{
   ExtCCData* eccData = (ExtCCData*)data;

//   fprintf(stderr," i = %d, j = %d, S.size() = %d\n", i, j, eccData->S.size() );
   assert( eccData != NULL );
   assert( i < (int)eccData->S.size() );
   assert( j < (int)eccData->S.size() );
   assert( i >= 0 );
   assert( j >= 0 );

   if (d == AnyDemand)
   {

	  if ( eccData->S[j] != eccData->S[i] )
          return 1.0;
      else
          return 0.0;
   }

   if (d > eccData->capacity)
      return 0.0;
   if ( eccData->S[j] && !eccData->S[i] )
      return eccData->incapcoeff[d];
   else if( !eccData->S[j] && eccData->S[i] )
      return eccData->outcapcoeff[d];
   else
      return 0.0;
}

bool ExtCC_IsEqual( void* data1, void* data2 )
{
   ExtCCData* eccData1 = (ExtCCData*)data1;
   ExtCCData* eccData2 = (ExtCCData*)data2;
   unsigned int i;
   if (eccData1->weightS != eccData2->weightS)
      return false;
   if (eccData1->S.size() != eccData2->S.size())
      return false;
   for (i = 0; i < eccData1->S.size(); i++)
      if (eccData1->S[i] != eccData2->S[i])
         return false;
   if (eccData1->capacity != eccData2->capacity)
      return false;
   if (eccData1->incapcoeff.size() != eccData2->incapcoeff.size())
      return false;
   for (i = 0; i < eccData1->incapcoeff.size(); i++)
      if (eccData1->incapcoeff[i] != eccData2->incapcoeff[i])
         return false;
   if (eccData1->outcapcoeff.size() != eccData2->outcapcoeff.size())
      return false;
   for (i = 0; i < eccData1->outcapcoeff.size(); i++)
      if (eccData1->outcapcoeff[i] != eccData2->outcapcoeff[i])
         return false;
   return true;
}

void* ExtCC_CopyData( void* data )
{
   ExtCCData* eccData = (ExtCCData*)data;
   ExtCCData* copied = new ExtCCData;
   *copied = *eccData;
   return copied;
}

void ExtCC_DestroyData( void* data )
{
   ExtCCData* eccData = (ExtCCData*)data;
   delete eccData;
}

// data structure that uses a tree to implement a set of sets of vertices
struct SetsTree
{
   bool endSet;
   std::vector<SetsTree> vertex;

   SetsTree()
   {
      endSet = false; // an empty set of sets
   }

   // return true if the set "target" starting at position "pos" is found
   bool find( int pos, std::vector<bool>& target )
   {
      int i;
      for (i = pos; i < (int)target.size(); i++)
      {
         if (target[i]) break;
      }
      if (i == (int)target.size()) return endSet;
      if (vertex[i].vertex.size() == 0) return false;
      return vertex[i].find( i+1, target );
   }

   // add the set "added" starting at position "pos"
   void add( int pos, std::vector<bool>& added )
   {
      int i;
      for (i = pos; i < (int)added.size(); i++)
      {
         if (added[i]) break;
      }
      if (i == (int)added.size())
      {
         endSet = true;
         return;
      }
      if (vertex[i].vertex.size() == 0)
         vertex[i].vertex.resize( added.size() );
      vertex[i].add( i+1, added );
   }
};

void CutGenerator::extCapCutGenByHeur( CutList* cuts )
{
   int num = 0;
   int den = 0;
   int cap = instance_.capacity;
   int setCount = 0;  
   
	std::vector<std::vector<int> > populacao_indices_S;
	std::vector<int> populacao_a;
	std::vector<int> populacao_b;
	
	int nS = 0;

   // Create the symmetric adjacency lists of vertices
   std::vector< std::vector<int> > adjVertex( instance_.numNodes );
   std::vector< std::vector<double> > adjValue( instance_.numNodes );
   for (int k = 0; k < solution->numArcs; k++)
   {
      if (solution->arcs[k].value < EccSetConnectEps) continue;
      int l;
      int i = solution->arcs[k].i;
      int j = solution->arcs[k].j;
      if ((i == 0) || (j == 0)) continue;
      for (l = 0; l < (int)adjVertex[i].size(); l++)
         if (adjVertex[i][l] == j) break;
      if (l == (int)adjVertex[i].size())
      {
         adjVertex[i].push_back(j);
         adjValue[i].push_back(solution->arcs[k].value);
      }
      else
      {
         adjValue[i][l] += solution->arcs[k].value;
      }
      for (l = 0; l < (int)adjVertex[j].size(); l++)
         if (adjVertex[j][l] == i) break;
      if (l == (int)adjVertex[j].size())
      {
         adjVertex[j].push_back(i);
         adjValue[j].push_back(solution->arcs[k].value);
      }
      else
      {
         adjValue[j][l] += solution->arcs[k].value;
      }
   }

   // Create the adjacency lists of capacitated arcs
   std::vector< std::vector<int> > adjCapArcs( instance_.numNodes );
   for (int k = 0; k < solution->numArcsCap; k++)
   {
      int i = solution->arcsCap[k].i;
      int j = solution->arcsCap[k].j;
      adjCapArcs[i].push_back( k );
      adjCapArcs[j].push_back( k );
      //fprintf( stdout, "x(%d,%d,%d) = %lf\n", i, j, solution->arcsCap[k].d,
        //    solution->arcsCap[k].value );
   }

   // Created an empty set of sets
   SetsTree setOfSets;
   setOfSets.vertex.resize(instance_.numNodes);

   // for each starting vertex except the root
   for (int v = 1; v < instance_.numNodes; v++)
   {
      // initialize the set of vertices and the candidates to enter
      std::vector<bool> inSet( instance_.numNodes, false );
      inSet[nextEccVertex] = true;
      std::vector<int> vertexSet;
      vertexSet.push_back( nextEccVertex );
      std::vector<int> candidates = adjVertex[nextEccVertex];
      int lastVertex = nextEccVertex;
      int setDemand = instance_.demand[lastVertex];

      // initialize the maps of LHS increases for the ECCs
      RationalMap incBeforeMap;
      RationalMap incAfterMap;

      // loop increasing the set while possible
      for (;;)
      {
         // initialize the changes in the y and z variables
         YZChange chg;
         chg.prevSetDem = setDemand - instance_.demand[lastVertex];
         for (int k = 0; k < (int)adjCapArcs[lastVertex].size(); k++)
         {
            CUTS_ArcCapVariable ac = solution->arcsCap[adjCapArcs[lastVertex][k]];
            //fprintf( stderr, "updating with x(%d,%d,%d) = %lf\n", ac.i, ac.j,
            //      ac.d, ac.value );
            if (ac.i == lastVertex)
            {
               if (inSet[ac.j])
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( -ac.value );
               }
               else
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( ac.value );
               }
            }
            else if (ac.j == lastVertex)
            {
               if (inSet[ac.i])
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( -ac.value );
               }
               else
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( ac.value );
               }
            }
            else
            {
               fprintf( stderr, "ERROR: Arc (%d,%d,%d) is adjacent to %d.\n",
                     ac.i, ac.j, ac.d, lastVertex );
            }
         }

         // printf the set
         /*fprintf(stderr,"Set: S =" );
         for (int j = 0; j < (int)vertexSet.size(); j++)
            fprintf( stderr, " %d", vertexSet[j] );
         fprintf(stderr,"\n");*/

         // evaluate the cut for the current set
         RECC_DoRoundings(chg, incBeforeMap, incAfterMap, cap, setDemand, num,
               den);
		 //fprintf( stderr, "a= %d, b= %d (%lf)\n", num, den, num/(double)den );
         setCount++;
         if (genSingleECCCut( cuts, num, den, 0,
               &vertexSet[0], vertexSet.size(), ECC_VIOLATED_EPS ))
         {
#ifdef PRINT_CUT
             fprintf( stderr, "ECC %d: viol = %lf, r = %d/%d, dem = %d.\n  Set = { %d",
                  cuts->numCuts, cuts->cuts[cuts->numCuts-1].violation,
                  num, den, setDemand, vertexSet[0] );
            for (int i = 1; i < (int)vertexSet.size(); i++)
               fprintf( stderr, ", %d", vertexSet[i] );
            fprintf( stderr, "}\n" ); 	
#endif
			 
			std::vector<int> indices(instance_.numNodes);		
			for (int j = 0; j < (int)vertexSet.size(); j++) 
			{
				indices[vertexSet[j]] = 1;
			}
			populacao_indices_S.push_back(indices);
			populacao_a.push_back(num);
			populacao_b.push_back(den);

            if (cuts->numCuts >= cutBatch) 
			{				   
				double distancia = 0;

				for (int i = 0; i < (int)populacao_indices_S.size()-1; i++) 
 				{
					for (int j = i+1; j < (int)populacao_indices_S.size();j++) 
					{
						nS++;
						int a1 = populacao_a[i];
						int a2 = populacao_a[j];
						int b1 = populacao_b[i];
						int b2 = populacao_b[j];

						double dif_r = a1/(double)b1- a2/(double)b2;

						distancia += fabs(dif_r)*2;
						for (int k = 0; k < (int)populacao_indices_S[i].size(); k++) 
						{			
							if (populacao_indices_S[i][k] != populacao_indices_S[j][k]) 
							{
								distancia += 1;
							}
						}
					}
				}
				cuts->diversity = distancia/nS;
				
				return;
			}
         }

         // save the set as already evaluated
         setOfSets.add(0, inSet);

         // evaluate all candidate vertices to be inserted in the set
         int bestCand = 0;
         int bestPos = -1;
         double bestViol = -2.0 * (cap + vertexSet.size());
         for (int k = 0; k < (int)candidates.size(); k++)
         {
            // skip if the new set has already been generated
            int i = candidates[k];
            inSet[i] = true;
            if (setOfSets.find(0, inSet))
            {
               // printf the repeated set
               //fprintf(stderr,"Repeated Set: S =" );
               //for (int j = 0; j < (int)vertexSet.size(); j++)
               //   fprintf( stderr, " %d", vertexSet[j] );
               //fprintf(stderr," %d\n", i);

               inSet[i] = false;
               continue;
            }

            // evaluate the cut using the new set (and the same multiplier)
            setDemand += instance_.demand[i];
            vertexSet.push_back(i);
            genSingleECCCut( cuts, num, den, 0, &vertexSet[0],
                  vertexSet.size(), 1.1 ); // never keep this cut
            double viol = cuts->cuts[cuts->numCuts].violation;
            if (viol < 0.0)
            {
               viol = -2.0 * vertexSet.size();
               for (int kk = 0; kk < (int)adjVertex[i].size(); kk++)
               {
                  int ii = adjVertex[i][kk];
                  if (inSet[ii])
                  {
#ifdef MAX_NUM_ARCS_SET
                     viol += 1.0;
#else
                     viol += adjValue[i][kk];
#endif
                  }
               }
            }

            // check for the best candidate vertex
            //double viol = cuts->cuts[cuts->numCuts].violation /
            //      cuts->cuts[cuts->numCuts].rhs;
            if (viol > bestViol)
            {
               bestViol = viol;
               bestCand = i;
               bestPos = k;
            }

            // restore the set
            inSet[i] = false;
            setDemand -= instance_.demand[i];
            vertexSet.pop_back();
         }

         // stop if no valid candidate has been found
         if (bestCand == 0) break;

         //fprintf( stderr, "Inserting vertex %d. violation = %lf.\n", bestCand,
         //      bestViol );

         // update the set and the list of candidates
         if (bestPos < (int)candidates.size() - 1)
            candidates[bestPos] = candidates[candidates.size() - 1];
         candidates.pop_back();
         for (int k = 0; k < (int)adjVertex[bestCand].size(); k++)
         {
            int i = adjVertex[bestCand][k];
            if (!inSet[i])
            {
               int l;
               for (l = 0; l < (int)candidates.size(); l++)
                  if (candidates[l] == i) break;
               if (l == (int)candidates.size())
                  candidates.push_back(i);
            }
         }
         inSet[bestCand] = true;
         setDemand += instance_.demand[bestCand];
         vertexSet.push_back(bestCand);
         lastVertex = bestCand;
      }

#ifdef DEC_ECC_SET		

	// loop decreasing the set while possible
      for (;;)
      {
         // evaluate all candidate vertices to be removed from the set
         int bestCand = 0;
         int bestPos = -1;
         double bestViol = -2.0 * (cap + vertexSet.size());
         int aux = vertexSet[(int)vertexSet.size() - 1];
         for (int k = 0; k < (int)vertexSet.size(); k++)
         {
            // skip if the new set has already been generated
            int i = vertexSet[k];
            inSet[i] = false;
            if (setOfSets.find(0, inSet))
            {
               // printf the repeated set
               //fprintf(stderr,"Repeated Set: S =" );
               //for (int j = 0; j < (int)vertexSet.size(); j++)
               //   if (j != k)
               //      fprintf( stderr, " %d", vertexSet[j] );
               //fprintf(stderr,"\n", i);
				

               inSet[i] = true;
               continue;
            }

            // evaluate the cut using the new set (and the same multiplier)
            setDemand -= instance_.demand[i];
            if (k < (int)vertexSet.size() - 1)
               vertexSet[k] = aux;
            vertexSet.pop_back();
            genSingleECCCut( cuts, num, den, 0, &vertexSet[0],
                  vertexSet.size(), 1.1 ); // never keep this cut
            double viol = cuts->cuts[cuts->numCuts].violation;
            if (viol < 0.0)
            {
               viol = -1.0;
               for (int kk = 0; kk < (int)adjVertex[i].size(); kk++)
               {
                  int ii = adjVertex[i][kk];
                  if (inSet[ii])
                  {
#ifdef MAX_NUM_ARCS_SET
                     viol -= 1.0;
#else
                     viol -= adjValue[i][kk];
#endif
                  }
               }
            }

            // check for the best candidate vertex
            //double viol = cuts->cuts[cuts->numCuts].violation /
            //      cuts->cuts[cuts->numCuts].rhs;
            if (viol > bestViol)
            {
               bestViol = viol;
               bestCand = i;
               bestPos = k;
            }

            // restore the set
            inSet[i] = true;
            setDemand += instance_.demand[i];
            vertexSet.push_back(aux);
            vertexSet[k] = i;
         }
		 
	

         // stop if no valid candidate has been found
         if (bestCand == 0) break;

         //fprintf( stderr, "Inserting vertex %d. violation = %lf.\n", bestCand,
         //      bestViol );

         // update the set
         inSet[bestCand] = false;
         setDemand -= instance_.demand[bestCand];
         if (bestPos < (int)vertexSet.size() - 1)
            vertexSet[bestPos] = aux;
         vertexSet.pop_back();
         lastVertex = bestCand;

         // initialize the changes in the y and z variables
         YZChange chg;
         chg.prevSetDem = setDemand + instance_.demand[lastVertex];
         for (int k = 0; k < (int)adjCapArcs[lastVertex].size(); k++)
         {
            CUTS_ArcCapVariable ac = solution->arcsCap[adjCapArcs[lastVertex][k]];
            //fprintf( stderr, "updating with x(%d,%d,%d) = %lf\n", ac.i, ac.j,
            //      ac.d, ac.value );
            if (ac.i == lastVertex)
            {
               if (inSet[ac.j])
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( ac.value );
               }
               else
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( -ac.value );
               }
            }
            else if (ac.j == lastVertex)
            {
               if (inSet[ac.i])
               {
                  chg.demZ.push_back( ac.d );
                  chg.valZ.push_back( ac.value );
               }
               else
               {
                  chg.demY.push_back( ac.d );
                  chg.valY.push_back( -ac.value );
               }
            }
            else
            {
               fprintf( stderr, "ERROR: Arc (%d,%d,%d) is adjacent to %d.\n",
                     ac.i, ac.j, ac.d, lastVertex );
            }
         }

         // printf the set
         //fprintf(stderr,"Set: S =" );
         //for (int j = 0; j < (int)vertexSet.size(); j++)
         //   fprintf( stderr, " %d", vertexSet[j] );
         //fprintf(stderr,"\n");
		 
         // evaluate the cut for the current set
         RECC_DoRoundings(chg, incBeforeMap, incAfterMap, cap, setDemand, num,
               den);
         setCount++;
         if (genSingleECCCut( cuts, num, den, 0,
               &vertexSet[0], vertexSet.size(), ECC_VIOLATED_EPS ))
         {

            //fprintf( stderr, "ECC violation = %lf, r = %lf, dem = %d.\n",
            //      cuts->cuts[cuts->numCuts-1].violation,
            //      double(num)/double(den), setDemand );
            if (cuts->numCuts >= cutBatch) return;
         }

         // save the set as already evaluated
         setOfSets.add(0, inSet);
      }

#endif

      // change to the next starting vertex
      nextEccVertex++;
      if (nextEccVertex == instance_.numNodes)
         nextEccVertex = 1;
   }
   
	double distancia = 0;

	if (populacao_indices_S.size() > 2)
	{
		for (int i = 0; i < (int)populacao_indices_S.size()-1; i++) 
		{
			for (int j= i+1; j< (int)populacao_indices_S.size(); j++) 
			{
				nS++;
				int a1 = populacao_a[i];
				int a2 = populacao_a[j];
				int b1 = populacao_b[i];
				int b2 = populacao_b[j];

				double dif_r = a1/(double)b1- a2/(double)b2;

				distancia += fabs(dif_r)*2;
				for (int k = 0; k < (int)populacao_indices_S[i].size(); k++) 
				{			
					if (populacao_indices_S[i][k] != populacao_indices_S[j][k]) 
					{
						distancia += 1;
					}
				}
			}
		}
		cuts->diversity = distancia/nS;
	} else
	{
		cuts->diversity = 0;
	}

}


bool CutGenerator::genSingleECCCut( CutList* cuts, int num, int den,
      int subtr, int *SetList, int SetListSize, double minViolation)
{
   int i, d;
   int demand = 0;
   ExtCCData* auxdata = 0;
   double prevViol = 0.0;

   // update the previous violation if the set size of the previous cut is similar
   /*if (cuts->numCuts > 0)
      if (cuts->cuts[cuts->numCuts - 1].templabel[0] != '\0')
      {
         auxdata = (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
         int numCommon = 0;
         for (i = 0; i < SetListSize; i++)
            if (auxdata->S[SetList[i]] == 1) numCommon++;
         int setSize = 0;
         for (i = 0; i < (int)auxdata->S.size(); i++)
            setSize += auxdata->S[i];
         if (numCommon >= (1.0 - FRAC_DIFF_SET_ECC) * (setSize + SetListSize - numCommon))
            prevViol = cuts->cuts[cuts->numCuts - 1].violation;
      }*/

   // create data for the new constraint
   auxdata = new ExtCCData;
   auxdata->S.resize( instance_.numNodes, 0 );
   auxdata->capacity = instance_.capacity;

   // prepare the vector of coefficients by demand
   auxdata->incapcoeff.resize(instance_.capacity + 1);
   auxdata->outcapcoeff.resize(instance_.capacity + 1);

   // Calculate the set demand and initialize the set of vertices
   for (i = 0; i < SetListSize; i++)
   {
      auxdata->S[SetList[i]] = 1;
      demand += instance_.demand[SetList[i]];
   }
   auxdata->weightS = demand;

   // calculate the right-hand side
   //double rhs = (double)eccceil((long long)demand * (long long)num, den);
   double rhs = eccfrac((long long)demand * (long long)num, den);
   if (rhs > 0) rhs = 1.0 - rhs;

   double fCoeff, alpha;
   for (d = 0; d <= instance_.capacity; d++ )
   {
      int dd = d - subtr;

      // Set coefficients for variables entering S
      fCoeff = eccfrac((long long)dd * (long long)num, den);
      if( fCoeff == 0 )
      {
         //auxdata->incapcoeff[d] = double((long long)dd * (long long)num) / double(den);
         auxdata->incapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0; //eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den);
            auxdata->incapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->incapcoeff[d] = fCoeff/alpha - fCoeff;
      }


      // Set coefficients for variables leaving S
      fCoeff = eccfrac(-(long long)dd * (long long)num, den);
      if( fCoeff == 0 )
      {
         //auxdata->outcapcoeff[d] = (double)(-(long long)dd * (long long)num) / double(den);
         auxdata->outcapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0;// eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den);
            auxdata->outcapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->outcapcoeff[d] = fCoeff/alpha - fCoeff;

      }
   }

   // fill the cut fields
   cuts->cuts[cuts->numCuts].data = auxdata;
   cuts->cuts[cuts->numCuts].sense = '>';
   cuts->cuts[cuts->numCuts].rhs = rhs;
   cuts->cuts[cuts->numCuts].GetArcCoeff = ExtCC_GetArcCoeff;
   cuts->cuts[cuts->numCuts].GetArcCapCoeff = ExtCC_GetArcCapCoeff;
   cuts->cuts[cuts->numCuts].IsEqual = ExtCC_IsEqual;
   cuts->cuts[cuts->numCuts].CopyData = ExtCC_CopyData;
   cuts->cuts[cuts->numCuts].DestroyData = ExtCC_DestroyData;
   sprintf(cuts->cuts[cuts->numCuts].templabel, "HECC" );

   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
      if (prevViol > 0)
      {
         if (cuts->cuts[cuts->numCuts].violation > prevViol)
         {
            delete (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
            cuts->cuts[cuts->numCuts - 1] = cuts->cuts[cuts->numCuts];
            return true;
         }
         else
         {
            delete auxdata;
            return false;
         }
      }
      else
      {
         cuts->numCuts++;
         return true;
      }
   }
   else
   {
      delete auxdata;
      return false;
   }
}

double CutGenerator::eccfrac(long long num, int den )
{
   if(!den)
   {
      fprintf(stdout,"Error -> den = 0 in line %d of %s\n", __LINE__, __FILE__ );
      exit(1);
   }
   long long div = num / den;
   if( div * den == num )
      return 0.0;
   else
   {
      if( num > 0 )
         return (double)num/den-div;
      else
         return (double)num/den-div+1;
   }
}

int CutGenerator::eccceil(long long num, int den )
{
   if(!den)
   {
      fprintf(stdout,"Error -> den = 0 in line %d of %s\n", __LINE__, __FILE__ );
      exit(1);
   }
   long long div = num / den;
   if( div * den == num )
      return div;
   else
   {
      if( num > 0 )
         return div+1;
      else
         return div;
   }
}

/**========================================================***
***      FUNCTIONS FOR EXTENDED CYCLE ELIMINATION CUTS     ***
***========================================================**/

void* GenericCut_CopyData( void* data )
{
   GenericCutData* cutData = (GenericCutData*)data;
   GenericCutData* copied = new GenericCutData;
   *copied = *cutData;
   return copied;
}

bool GenericCut_IsEqual( void* data1, void* data2 )
{
   GenericCutData* cut1 = (GenericCutData*)data1;
   GenericCutData* cut2 = (GenericCutData*)data2;
   ArcCapCoeffHash::iterator it1;
   ArcCapCoeffHash::iterator it2;
   if( cut1->coeffs.size() != cut2->coeffs.size() )
      return false;
   for( it1 = cut1->coeffs.begin(); it1 != cut1->coeffs.end(); it1++ )
   {
      it2 = cut2->coeffs.find( (*it1).first );
      if( it2 == cut2->coeffs.end() )
         return false;
      if( fabs( (*it1).second - (*it2).second ) > 1e-6 )
         return false;
   }
   return true;
}

void GenericCut_AddCoeff( void* data, int i, int j, int d, double coeff )
{
   GenericCutData* cutData = (GenericCutData*)data;
   ArcCapCoeffHash::iterator it;
   ArcCapHashKey k;

   k.i = i;
   k.j = j;
   k.d = AnyDemand;
   cutData->coeffs[ k ] = 1.0;

   k.i = i;
   k.j = j;
   k.d = d;
   it = cutData->coeffs.find( k );
   if( it == cutData->coeffs.end() )
      cutData->coeffs[ k ] = coeff;
   else
      cutData->coeffs[ k ] += coeff;
}

double GenericCut_GetArcCoeff( void* data, int i, int j )
{
//   GenericCutData* cutData = (GenericCutData*)data;
   return 0.0;
}

double GenericCut_GetArcCapCoeff( void* data, int i, int j, int d )
{
   GenericCutData* cutData = (GenericCutData*)data;
   ArcCapCoeffHash::iterator it;
   ArcCapHashKey k;

   k.i = i;
   k.j = j;
   k.d = d;
   it = cutData->coeffs.find( k );
   if( it == cutData->coeffs.end() )
      return 0.0;
   else
      return (*it).second;
}

void GenericCut_DestroyData( void* data )
{
   GenericCutData* cutData = (GenericCutData*)data;
   delete cutData;
}

struct NodeCapGraph
{
   int i;
   int d;
   std::vector<int> adjArcs;   // indices of outgoing adjacent arcs
   std::vector<NodeCapGraph*> adjNodes; // corresponding adjacent nodes

   // auxiliary attributes
   NodeCapGraph* parent;   // current parent in the traversal tree
   double flow;            // total flow to pass further
   int nextArc;            // index of the next arc to pass flow through
   double remain;          // remaining flow to pass through "nextArc"
};

struct NodeCapHashKey
{
   int i;
   int d;
#ifdef _WIN32
   operator size_t() const
   {
      return (i + d*300);
   }
#endif
   bool operator< ( const NodeCapHashKey &node ) const
   {
      if (i != node.i) return (i < node.i);
      return (d < node.d);
   }
};

#ifndef _WIN32
struct eqNodeCapKey
{
   bool operator() ( const NodeCapHashKey &node1, const NodeCapHashKey &node2 ) const
   {
      return( (node1.i == node2.i) && (node1.d == node2.d) );
   }
};

struct hashNodeCapKey
{
   size_t operator() ( const NodeCapHashKey &node ) const
   {
      hash<int> H;
      return( H(node.i + node.d*1000) );
   }
};
#endif

#ifdef _WIN32
typedef hash_map< NodeCapHashKey, NodeCapGraph > NodeCapGraphHash;
#else
typedef hash_map< NodeCapHashKey, NodeCapGraph, hashNodeCapKey, eqNodeCapKey > NodeCapGraphHash;
#endif

void CutGenerator::extCyElimCutGenByHeur( CutList* cuts )
{
   NodeCapGraphHash graphHash;
   std::vector<NodeCapGraph*> rootNodes;
   std::vector< std::vector<bool> > sets;

   // build the adjacency list of existing nodes in the support graph
   for (int k = 0; k < solution->numArcsCap; k++)
   {
      // skip the arcs whose flows are too small
      if (solution->arcsCap[k].value < ECEC_VIOLATED_EPS) continue;

      // add the tail node to the hash table if necessary
      NodeCapHashKey node;
      node.i = solution->arcsCap[k].i;
      node.d = solution->arcsCap[k].d + instance_.demand[node.i];
      NodeCapGraphHash::iterator it = graphHash.find( node );
      if (it == graphHash.end())
      {
         NodeCapGraph nodeGr;
         nodeGr.i = node.i;
         nodeGr.d = node.d;
         nodeGr.parent = 0;
         nodeGr.flow = 0.0;
         nodeGr.nextArc = 0;
         nodeGr.remain = 0;
         graphHash[node] = nodeGr;

         // store the sources of flow (at the root node)
         if (node.i == 0)
            rootNodes.push_back( &graphHash[node] );
      }

      // add the arc to the adjacent list of the node
      NodeCapGraph* nodeGrPtr = &graphHash[node];
      nodeGrPtr->adjArcs.push_back(k);
      if (node.i == 0)
         nodeGrPtr->flow += solution->arcsCap[k].value;
      if (nodeGrPtr->adjArcs.size() == 1)
         nodeGrPtr->remain = solution->arcsCap[k].value;

      // add the head node to the hash table if necessary
      NodeCapHashKey node2;
      node2.i = solution->arcsCap[k].j;
      node2.d = solution->arcsCap[k].d;
      it = graphHash.find( node2 );
      if (it == graphHash.end())
      {
         NodeCapGraph nodeGr;
         nodeGr.i = node2.i;
         nodeGr.d = node2.d;
         nodeGr.parent = 0;
         nodeGr.flow = 0.0;
         nodeGr.nextArc = 0;
         nodeGr.remain = 0;
         graphHash[node2] = nodeGr;
      }
      //fprintf( stderr, " (%d,%d)->(%d,%d)", node.i, node.d, node2.i, node2.d );

      // add the arc to the adjacent list of the node
      nodeGrPtr->adjNodes.push_back( &graphHash[node2] );
   }
   //fprintf( stderr, "\n" );

   //fprintf( stderr, "Flow decomposition:\n" );
   for (int s = 0; s < (int)rootNodes.size(); s++)
   {
      NodeCapGraph* node = rootNodes[s];
      while (node != 0)
      {
         double flow = node->flow;
         NodeCapGraph* next = 0;

         // if no more flow to pass
         if (flow < ECEC_VIOLATED_EPS)
         {
            // go bach to the parent
            node = node->parent;
            continue;
         }

         // if no more space to pass flow
         if (node->nextArc >= (int)node->adjArcs.size())
         {
            // if at the root, check if the current path has cycles
            if ((node->i == 0) && (node->parent != 0))
            {
               //fprintf( stderr, "flow %g:", node->flow );
               node->flow = 0;
               flow = 0;

               // find cycles in the path
               std::vector<NodeCapGraph*> lastNodeVisit( instance_.numNodes,
                     (NodeCapGraph*)0 );
               next = node->parent;
               while (next->i != 0)
               {
                  // Add the cut if a cycle has been found
                  if ((lastNodeVisit[next->i] != 0) && (cuts->numCuts < cutBatch))
                  {
                     // build the node set
                     std::vector<int> nodeSet;
                     std::vector<bool> flagSet(instance_.numNodes, false);
                     nodeSet.push_back(0);
                     NodeCapGraph* start = lastNodeVisit[next->i]->parent;
                     while (start != next)
                     {
                        nodeSet.push_back(start->i);
                        flagSet[start->i] = true;
                        start = start->parent;
                     }

                     // check if the set has not been tested before
                     int t;
                     for (t = 0; t < (int)sets.size(); t++)
                     {
                        if (sets[t] == flagSet) break;
                     }
                     if (t >= (int)sets.size())
                     {
                        // save the current set
                        sets.push_back( flagSet );

                        // do the separation
                        std::vector<int> heads;
                        std::vector<int> tails;
                        std::vector<int> demands;
                        std::vector<double> coeffs;
                        std::vector<int> nodeDems(instance_.numNodes+1, 0);
                        for (int d = 1; d < instance_.numNodes; d++)
                           nodeDems[d] = instance_.demand[d];
                        ExtCycleEliminator cycleElim(solution, &nodeDems[0],
                                instance_.capacity, &nodeSet[0], nodeSet.size()-1);
                        if ( cycleElim.generateCut(heads, tails, demands, coeffs) )
                        {
                           // create the specific data for the generic cut
                           GenericCutData* auxdata = new GenericCutData;

                           // get the coefficients for the cut
                           int nvars = coeffs.size();
                           for( int j = 0; j < nvars; j++ )
                           {
                              GenericCut_AddCoeff( auxdata, tails[j], heads[j], demands[j],
                                    coeffs[j] );
                           }

                           // Add cut to the cut list
                           cuts->cuts[cuts->numCuts].data = auxdata;
                           cuts->cuts[cuts->numCuts].sense = '<';
                           cuts->cuts[cuts->numCuts].rhs = 0.0;
                           cuts->cuts[cuts->numCuts].GetArcCoeff = GenericCut_GetArcCoeff;
                           cuts->cuts[cuts->numCuts].GetArcCapCoeff = GenericCut_GetArcCapCoeff;
                           cuts->cuts[cuts->numCuts].IsEqual = GenericCut_IsEqual;
                           cuts->cuts[cuts->numCuts].CopyData = GenericCut_CopyData;
                           cuts->cuts[cuts->numCuts].DestroyData = GenericCut_DestroyData;
                           sprintf(cuts->cuts[cuts->numCuts].templabel, "ECEC" );

                           // Double check the cut violation
                           if ( isViolated(&cuts->cuts[cuts->numCuts], ECEC_VIOLATED_EPS) )
                           {
                              //fprintf( stderr, "Found ECEC with viol=%g\n",
                              //      cuts->cuts[cuts->numCuts].violation );
                              cuts->numCuts++;
                           }
                           else
                           {
                              // printf( "CUT NOT VIOLATED!!!\n" );
                              ResetCut( &( cuts->cuts[cuts->numCuts] ) );
                           }
                        }
                     }
                  } // end "add the cut..."

                  // save the last capacitated node where this node was visited
                  //fprintf( stderr, " %d", next->i );
                  lastNodeVisit[next->i] = next;
                  next = next->parent;
               }

               //fprintf( stderr, "\n" );
            }

            // go bach to the parent
            // -> since the search is depth-first, the flow that may eventually
            //    come back from the child node does not need to be re-sent
            //    through the same arc because there is no way out of it.
            //    Hence, node->remain and node->nextArc do not need to be restored.
            node = node->parent;
            if (node != 0) node->flow += flow;
            continue;
         }

         // pass the flow and go to the child node
         next = node->adjNodes[node->nextArc];
         if (flow > node->remain) flow = node->remain;
         node->flow -= flow;
         node->remain -= flow;
         if (node->remain < ECEC_VIOLATED_EPS)
         {
            node->nextArc++;
            if (node->nextArc < (int)node->adjArcs.size())
            {
               int k = node->adjArcs[node->nextArc];
               node->remain = solution->arcsCap[k].value;
            }
         }
         next->flow += flow;
         next->parent = node;
         node = next;
      }
   }
}

//classe criada por Daniel
class Arco
{
public:
	int i,j, d_i, d_j, d;
	double valor;

	Arco(int i_, int j_, int d_, int d_i_, int d_j_, double valor_)
	{
		i = i_;
		j = j_;
		d = d_;
		d_i = d_i_;
		d_j = d_j_;
		valor = valor_;
	}

	bool Compativel(Arco &par) {
		if (j==par.i)
		{
			if (d == (par.d - d_j) )
				return true;
		}
		else if (i==par.j)
		{
			if (par.d == (d - d_i) )
				return true;
		}	
		
		return false;		
	}

	bool operator < (const Arco &arco) const
	{
		return (d > arco.d); //invertido para ordenar por capacidade decrescente
    }
};



bool CutGenerator::genSingleTriCliqueCut( CutList* cuts, int S_i, int S_j, int S_k, double minViolation )
{
	
    // create the specific data for the generic cut
    GenericCutData* auxdata = new GenericCutData;

	//fprintf(stderr,"Processing TriClique Cuts...\n");  
	
	std::vector<Arco> V;

	for (int k = 0; k < solution->numArcsCap; k++)
	{
      int i = solution->arcsCap[k].j;
      int j = solution->arcsCap[k].i;
      int d = solution->arcsCap[k].d;

	  if ( ( (i == S_i) || (i == S_j) || (i == S_k) ) && ( (j == S_i) || (j == S_j) || (j == S_k) ) )
	  {
		  V.push_back(Arco(i, j, d, instance_.demand[i], instance_.demand[j], solution->arcsCap[k].value));
		  //fprintf(stderr,"Adicionando arco %d: x%d_%d_%d = %lg\t",
			//	k, i, j, d, solution->arcsCap[k].value);  // codigo por Daniel Dias em 17-04-2015
	  }
	}
	//fprintf(stderr,"\n");

	std::vector<std::vector<Arco> > CHAIN;
	bool newChain = true;

	for (int ii = 0; ii < (int)V.size(); ii++)
	{
		newChain = true;
		for (int jj = 0; jj < (int)CHAIN.size(); jj++)
		{
			for (int kk = 0; kk < (int)CHAIN[jj].size(); kk++)
			{
				if (V[ii].Compativel(CHAIN[jj][kk]))
				{
					CHAIN[jj].push_back(V[ii]);
					newChain = false;
					break;
				}
			}
			if (!newChain)
				break;			
		}
		if (newChain)
		{
			std::vector<Arco> temp;
			temp.push_back(V[ii]);
			CHAIN.push_back(temp);
		}
	}
	
	for (int jj = 0; jj < (int)CHAIN.size(); jj++)
	{
		std::sort(CHAIN[jj].begin(),CHAIN[jj].end());

		if (CHAIN[jj].size() == 1)
		{
			GenericCut_AddCoeff( auxdata, CHAIN[jj][0].j , CHAIN[jj][0].i, CHAIN[jj][0].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][0].i ,CHAIN[jj][0].j, CHAIN[jj][0].d);
		} 
		else if (CHAIN[jj].size() == 2)
		{
			if (CHAIN[jj][0].valor > CHAIN[jj][1].valor)
			{
			GenericCut_AddCoeff( auxdata, CHAIN[jj][0].j , CHAIN[jj][0].i, CHAIN[jj][0].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][0].i ,CHAIN[jj][0].j, CHAIN[jj][0].d);
			}
			else
			{
				GenericCut_AddCoeff( auxdata, CHAIN[jj][1].j , CHAIN[jj][1].i, CHAIN[jj][1].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][1].i ,CHAIN[jj][1].j, CHAIN[jj][1].d);
			}				
		}
		else
		{
			if (CHAIN[jj][0].valor + CHAIN[jj][2].valor > CHAIN[jj][1].valor) 
			{
				GenericCut_AddCoeff( auxdata, CHAIN[jj][0].j , CHAIN[jj][0].i, CHAIN[jj][0].d, 1);
				GenericCut_AddCoeff( auxdata, CHAIN[jj][2].j , CHAIN[jj][2].i, CHAIN[jj][2].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][0].i ,CHAIN[jj][0].j, CHAIN[jj][0].d);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][2].i ,CHAIN[jj][2].j, CHAIN[jj][2].d);
			}
			else
			{
				GenericCut_AddCoeff( auxdata, CHAIN[jj][1].j , CHAIN[jj][1].i, CHAIN[jj][1].d, 1);
			//fprintf(stderr,"+ x%d_%d_%d ",CHAIN[jj][1].i ,CHAIN[jj][1].j, CHAIN[jj][1].d);
			}
		}
	}
	//fprintf(stderr,"\n");
	
	// Add cut to the cut list
    cuts->cuts[cuts->numCuts].data = auxdata;
    cuts->cuts[cuts->numCuts].sense = '<';
    cuts->cuts[cuts->numCuts].rhs = 1;
    cuts->cuts[cuts->numCuts].GetArcCoeff = GenericCut_GetArcCoeff;
    cuts->cuts[cuts->numCuts].GetArcCapCoeff = GenericCut_GetArcCapCoeff;
    cuts->cuts[cuts->numCuts].IsEqual = GenericCut_IsEqual;
    cuts->cuts[cuts->numCuts].CopyData = GenericCut_CopyData;
    cuts->cuts[cuts->numCuts].DestroyData = GenericCut_DestroyData;
    sprintf(cuts->cuts[cuts->numCuts].templabel, "ECEC" );
		
	double lhs = computeActivity( &cuts->cuts[cuts->numCuts] );

	//fprintf( stderr, "TCC %d: viol = %lf, lhs = %lf .\n",
    //              cuts->numCuts, cuts->cuts[cuts->numCuts].violation, lhs);


   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
		cuts->numCuts++;
		return true;      
   }
   else
   {
		delete auxdata;
		return false;
   }
}

bool CutGenerator::genGenericCliqueCut( CutList* cuts, std::vector<int> x_i, std::vector<int> x_j, std::vector<int> x_d, double minViolation )
{
	
    // create the specific data for the generic cut
    GenericCutData* auxdata = new GenericCutData;

	//fprintf(stderr,"Processing Generic Clique Cuts...\n");  
		
	
	for (int i = 0; i < (int)x_i.size(); i++)
	{
		GenericCut_AddCoeff( auxdata, x_j[i] , x_i[i], x_d[i], 1);
	}
	//fprintf(stderr,"\n");
	
	// Add cut to the cut list
    cuts->cuts[cuts->numCuts].data = auxdata;
    cuts->cuts[cuts->numCuts].sense = '<';
    cuts->cuts[cuts->numCuts].rhs = 1;
    cuts->cuts[cuts->numCuts].GetArcCoeff = GenericCut_GetArcCoeff;
    cuts->cuts[cuts->numCuts].GetArcCapCoeff = GenericCut_GetArcCapCoeff;
    cuts->cuts[cuts->numCuts].IsEqual = GenericCut_IsEqual;
    cuts->cuts[cuts->numCuts].CopyData = GenericCut_CopyData;
    cuts->cuts[cuts->numCuts].DestroyData = GenericCut_DestroyData;
    sprintf(cuts->cuts[cuts->numCuts].templabel, "ECEC" );
		
	double lhs = computeActivity( &cuts->cuts[cuts->numCuts] );

	//fprintf( stderr, "TCC %d: viol = %lf, lhs = %lf .\n",
    //              cuts->numCuts, cuts->cuts[cuts->numCuts].violation, lhs);


   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
		cuts->numCuts++;
		return true;      
   }
   else
   {
		delete auxdata;
		return false;
   }
}

bool CutGenerator::genSingleOECCut( CutList* cuts, int t, int m,								 
      int *SetList, int SetListSize, double minViolation )
{
   int i, d;
   int demand = 0;
   ExtCCData* auxdata = 0;

   // create data for the new constraint
   auxdata = new ExtCCData;
   auxdata->S.resize( instance_.numNodes, 0 );
   auxdata->capacity = instance_.capacity;

   // prepare the vector of coefficients by demand
   auxdata->incapcoeff.resize(instance_.capacity + 1, 0.0);
   auxdata->outcapcoeff.resize(instance_.capacity + 1, 0.0);

   // Calculate the set demand and initialize the set of vertices
   for (i = 0; i < SetListSize; i++)
   {
      auxdata->S[SetList[i]] = 1;
      demand += instance_.demand[SetList[i]];
   }
   auxdata->weightS = demand;

   // calculate the right-hand side
   double rhs = 2.0;

   //Y1
	for (d = t; d <= demand - t -(m-2)*(t-1); d++ )
		auxdata->incapcoeff[d] = 1.0;

	//Y2
	for (d = demand - t -(m-2)*(t-1) + 1; d <= instance_.capacity; d++ )
		auxdata->incapcoeff[d] = 2.0;

	//Z
	int tz1 = demand - t;
	int tz2 = instance_.capacity - demand + 2*t - 1;
	int tz = tz1 > tz2 ? tz1 : tz2; 
	for (d = tz; d < instance_.capacity; d++ )
		auxdata->outcapcoeff[d] = -1.0;
	
	// fill the cut fields
	cuts->cuts[cuts->numCuts].data = auxdata;
	cuts->cuts[cuts->numCuts].sense = '>';
	cuts->cuts[cuts->numCuts].rhs = rhs;
	cuts->cuts[cuts->numCuts].GetArcCoeff = ExtCC_GetArcCoeff;
	cuts->cuts[cuts->numCuts].GetArcCapCoeff = ExtCC_GetArcCapCoeff;
	cuts->cuts[cuts->numCuts].IsEqual = ExtCC_IsEqual;
	cuts->cuts[cuts->numCuts].CopyData = ExtCC_CopyData;
	cuts->cuts[cuts->numCuts].DestroyData = ExtCC_DestroyData;
	sprintf(cuts->cuts[cuts->numCuts].templabel, "HECC" );

   // Store the cut if violated
	if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
	{     
		cuts->numCuts++;
		return true;
	}
	else
	{
		delete auxdata;
		return false;
	}
}

bool CutGenerator::genSingleECCCut_s( CutList* cuts, int num, int den, int s_num,
      int subtr, int *SetList, int SetListSize, double minViolation)
{
   int i, d;
   int demand = 0;
   ExtCCData* auxdata = 0;
   double prevViol = 0.0;

   // update the previous violation if the set size of the previous cut is similar
   /*if (cuts->numCuts > 0)
      if (cuts->cuts[cuts->numCuts - 1].templabel[0] != '\0')
      {
         auxdata = (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
         int numCommon = 0;
         for (i = 0; i < SetListSize; i++)
            if (auxdata->S[SetList[i]] == 1) numCommon++;
         int setSize = 0;
         for (i = 0; i < (int)auxdata->S.size(); i++)
            setSize += auxdata->S[i];
         if (numCommon >= (1.0 - FRAC_DIFF_SET_ECC) * (setSize + SetListSize - numCommon))
            prevViol = cuts->cuts[cuts->numCuts - 1].violation;
      }*/

   // create data for the new constraint
   auxdata = new ExtCCData;
   auxdata->S.resize( instance_.numNodes, 0 );
   auxdata->capacity = instance_.capacity;

   // prepare the vector of coefficients by demand
   auxdata->incapcoeff.resize(instance_.capacity + 1);
   auxdata->outcapcoeff.resize(instance_.capacity + 1);

   // Calculate the set demand and initialize the set of vertices
   for (i = 0; i < SetListSize; i++)
   {
      auxdata->S[SetList[i]] = 1;
      demand += instance_.demand[SetList[i]];
   }
   auxdata->weightS = demand;

   // calculate the right-hand side
   //double rhs = (double)eccceil((long long)demand * (long long)num, den);
   double rhs = eccfrac((long long)demand * (long long)num, den);
   if (rhs > 0) rhs = 1.0 - rhs;

   double fCoeff, alpha;
   for (d = 0; d <= instance_.capacity; d++ )
   {
      int dd = d - subtr;

      // Set coefficients for variables entering S
      fCoeff = eccfrac((long long)dd * (long long)num + (long long)s_num, den);
      if( fCoeff == 0 )
      {
         //auxdata->incapcoeff[d] = double((long long)dd * (long long)num) / double(den);
         auxdata->incapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0; //eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den);
            auxdata->incapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->incapcoeff[d] = (double)eccceil((long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->incapcoeff[d] = fCoeff/alpha - fCoeff;
      }


      // Set coefficients for variables leaving S
      fCoeff = eccfrac(-(long long)dd * (long long)num - s_num, den);
      if( fCoeff == 0 )
      {
         //auxdata->outcapcoeff[d] = (double)(-(long long)dd * (long long)num) / double(den);
         auxdata->outcapcoeff[d] = 0.0;
      }
      else
      {
         alpha = 0.0;// eccfrac((long long)demand * (long long)num, den);
         if( fCoeff >= alpha - 0.0001)
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den);
            auxdata->outcapcoeff[d] = 1.0 - fCoeff;
         else
            //auxdata->outcapcoeff[d] = (double)eccceil(-(long long)dd * (long long)num, den)
            //      -1.0 + fCoeff/alpha;
            auxdata->outcapcoeff[d] = fCoeff/alpha - fCoeff;

      }
   }

   // fill the cut fields
   cuts->cuts[cuts->numCuts].data = auxdata;
   cuts->cuts[cuts->numCuts].sense = '>';
   cuts->cuts[cuts->numCuts].rhs = rhs;
   cuts->cuts[cuts->numCuts].GetArcCoeff = ExtCC_GetArcCoeff;
   cuts->cuts[cuts->numCuts].GetArcCapCoeff = ExtCC_GetArcCapCoeff;
   cuts->cuts[cuts->numCuts].IsEqual = ExtCC_IsEqual;
   cuts->cuts[cuts->numCuts].CopyData = ExtCC_CopyData;
   cuts->cuts[cuts->numCuts].DestroyData = ExtCC_DestroyData;
   sprintf(cuts->cuts[cuts->numCuts].templabel, "HECC" );

   // Store the cut if violated
   if ( isViolated(&cuts->cuts[cuts->numCuts], minViolation) )
   {
      if (prevViol > 0)
      {
         if (cuts->cuts[cuts->numCuts].violation > prevViol)
         {
            delete (ExtCCData*)cuts->cuts[cuts->numCuts - 1].data;
            cuts->cuts[cuts->numCuts - 1] = cuts->cuts[cuts->numCuts];
            return true;
         }
         else
         {
            delete auxdata;
            return false;
         }
      }
      else
      {
         cuts->numCuts++;
         return true;
      }
   }
   else
   {	   
		fprintf( stderr, "\nError, invalid cut, viol:%f; a:%d; b:%d; snum:%d\nS: {",
			cuts->cuts[cuts->numCuts].violation, num, den, s_num );
		for (i = 0; i < SetListSize; i++)
		{
		fprintf( stderr, "%d ," ,
			SetList[i] );
		}
		fprintf( stderr, "}\n");


		delete auxdata;
		return false;
   }
}

//OEC Separation

const bool elimina_por_semelhanca_cardinalidade = false;
const double cardinalidade_relevante = 0.8;

const int tamanhoPopulacao = 20;
const int totalIter = 100;
const double percFilho = 1;
const int TcountRelevante = 20;
const int limiteCortes = 50;	
const double gapRelevante = -0.05000001;

const bool busca_local_modificada = false;
const int k_busca_local_modificada = 200;

const bool logDetalhado = false;
const bool logDetalhadoAssinaturas = false;
const bool logDetalhadoMinhoca = false;	
const bool logEfeitoCrossover = false;

const bool crossoverConexo = true;
const bool buscaConexa = true;

const int tamanhoMin = 2; //tamanho minimo que o conjunto S pode ter

using namespace std;


vector<Individual> inicializaPopulacao(int tamanhoPopulacao, Instance& inst, Solution& sol);

void buscaLocalOEC(Instance& inst, Individual indiv, Solution& sol, vector<Individual> &violados, 
			vector<vector< bool > >& conjuntoSbuscados, int level, int tabu, double previousBestGap);


Individual * crossover (Individual &pai, Individual &mae, Instance& inst, Solution& sol, vector<vector<bool> > conjuntoSbuscados);

bool conjuntoSbuscado(vector<vector<bool> > &conjuntoSbuscados, vector<bool> &conjuntoSbool, bool registrar);

bool insertUniqueIndividual(vector<Individual> &population, Individual &newIndividual);

bool verifica_novo_Individual(vector<Individual> &gerados, string &impressaoS); 

bool verifica_novo_Individual_completo(vector<Individual> &gerados, Individual &novo_Individual);

void CalculateOEC(int pTotal, vector<double>& Y_vec, vector<double>& Z_vec, Solution& sol, Instance&  inst,
				int& t, double& lhs, double& rhs);

string imprimeS(vector<int> S);

void selecionaPopulacao(vector<Individual> &populacao, int tamanhoLimite);

double calculaDiversidade(vector<Individual> &populacao, int nIndividuals = -1);

void CutGenerator::extOECGenByHeur( CutList* cuts )
{	
	int i;
	
	bool erro = false;
	Instance inst(instance_);
	Solution sol(inst, *solution);

	if (erro)
		return;
	
	double diversidade = 0;
	double diversidadeAnterior = 0;
	int quantidadeCrossoversMax = int(ceil(tamanhoPopulacao*percFilho));
	
	vector<vector<bool> > conjuntoSbuscados;
	
	vector<Individual> violados;
		
	vector<Individual> populacao = inicializaPopulacao(tamanhoPopulacao, inst, sol);   //inicializaPopulacao

	for (i=0; i < (int)populacao.size(); i++)
	{
		populacao[i].S.calculaYZ(sol);
		populacao[i].calculateOEC(sol, inst);
	}

	//busca local em todos os membros da populacao gerada
	for (i=0; i < (int)populacao.size(); i++) {				
		buscaLocalOEC(inst, populacao[i], sol, violados, conjuntoSbuscados, 0, 0, 1000);
	}
	
	int totalCortesPop = violados.size();

	int iter = 1;

	while  (iter<=totalIter) // && (violados.size() < 10*limiteCortes) ) 
	{
		int quantidadeCrossovers = (quantidadeCrossoversMax > (int)populacao.size()) ? (populacao.size()) : (quantidadeCrossoversMax);

		//crossover com busca local
		if (populacao.size()>1) {
			int qtdDup = 0;
			int qtdNovo = 0;
			for (i=0;i<quantidadeCrossovers;i++) 
			{
				//seleciona aleatoriamente um pai e uma mae para Crossover
				int i_pai = std::rand() % populacao.size();
				int i_mae = std::rand() % populacao.size();
				while ((i_mae == i_pai) || (populacao[i_pai].assinatura == populacao[i_mae].assinatura)) 
				{
					i_pai = std::rand() % populacao.size();
					i_mae = std::rand() % populacao.size();				
				}
	
				Individual * filho = crossover(populacao[i_pai], populacao[i_mae], inst, sol, conjuntoSbuscados);

				if (!conjuntoSbuscado(conjuntoSbuscados, filho->S.pertenceS, false))
				{
					qtdNovo++;											
					buscaLocalOEC(inst, *filho, sol, violados, conjuntoSbuscados, 0, 0, 1000);
					populacao.push_back(*filho);						
				} 
				else 
				{
					qtdDup++;
					i--;
					if (qtdDup == quantidadeCrossovers*2)
						break;
				}
			}
		}

		//corta os elementos da populacao abaixo de um dado limite
		selecionaPopulacao(populacao, tamanhoPopulacao);

		diversidadeAnterior = diversidade;
		diversidade = calculaDiversidade(populacao);
		
		std::sort (populacao.begin(), populacao.end());
		iter++;
	}

	//passa o sarrafo nos violados
	if ((int)violados.size() > limiteCortes)	
	{
		std::sort (violados.begin(), violados.end());
		if ( (elimina_por_semelhanca_cardinalidade) && (violados.size() > limiteCortes) ) 
		{
			for (int i = 0; i < (int)violados.size()-1; i++) 
			{
				if (i == limiteCortes) break;
				int card_uniao = 0, card_intersec = 0;
				for (int j = i+1; j < (int)violados.size() ; j++) 
				{
					if (j == limiteCortes) break;
					for (int k = 1; k <= inst.n; k++) 
					{
						if ( violados[i].S.pertenceS[k] || violados[j].S.pertenceS[k] )	card_uniao++;
						if ( violados[i].S.pertenceS[k] && violados[j].S.pertenceS[k])	card_intersec++;
					}					
					if ( card_intersec > card_uniao*cardinalidade_relevante ) 
					{						
						violados.erase (violados.begin()+j);
						j--;
						if (violados.size() <= limiteCortes) break; //finaliza a busca por semelhantes				 			
					}
				}
				if (violados.size() <= limiteCortes) break;
				if (i == limiteCortes) break;
			}
		}
		if (violados.size() > limiteCortes) violados.erase (violados.begin()+limiteCortes, violados.end());		
	}

	diversidade = 0;
	
	if (violados.size() > 0) diversidade = calculaDiversidade(violados);

	for (int i = 0; i < (int)violados.size(); i++) {
		int tCorte = violados[i].t;
		int setSize = violados[i].S.elementos.size();

		std::vector<int> setDesc(setSize);
		for (int k = 0; k < setSize; k++) setDesc[k] = violados[i].S.elementos[k];
		
		genSingleOECCut(cuts, tCorte, inst.m, &setDesc[0], setSize, 0.05);
	}
}

vector<Individual> inicializaPopulacao(int tamanhoPopulacao, Instance& inst, Solution& sol) 
{	
	int n = inst.n; 
	vector <Individual> populacao;
	
	//C = {(j, \bar{C}_j)| j \in J}, where \bar{C}_j is the average completion time
	vector<InteDouble> C; //(index, completion time) of jobs

	//populate C - begin
	for (int i = 0; i < n; i++)
	{
		C.push_back(InteDouble(i+1,0));
	}

	for (int ii = 0; ii < (int)sol.arcs.size(); ii++)
	{
		int i = sol.arcs[ii].i;
		int j = sol.arcs[ii].j;
		int t = sol.arcs[ii].t;
		double valor = sol.arcs[ii].value;

		if (i>0)
			C[i-1] += t*valor;
	}
	//populate C - end

	//sorts C in ascending order of completion time
	//C[0][0] is the index of the first job to complete
	sort(C.begin(),C.end());

	for (int k = 1; k <= n; k++)
	{
		for (int j = 0; j < k; j++)
		{
			int jth_job = C[j].valor_int;

			vector<bool> kSmallest(n+1);
#ifndef REVERSE_OEC
			for (int i = 0; i < k; i++)	
			{
				kSmallest[C[i].valor_int] = true;
			}
#else			
			for (int i = 1; i <= k; i++)	
			{
				kSmallest[C[C.size()-i].valor_int] = true;
			}
#endif

			//performs Breadth-First-Search among the kSmallest jobs to find the connected components
			int contDescobertos;
			int no;
			vector<int> fila;
			vector<bool> descoberto;
			descoberto.resize(n+1);
			descoberto[jth_job] = true;
			contDescobertos = 1;
			fila.push_back(jth_job);

			while ( fila.size()>0 ) {
				//le e deleta o primeiro elemento da fila
				no = fila[0];
				fila.erase( fila.begin() );
				for (int i = 1; i <= sol.n; i++) 
				{
					if ( (sol.adjMatrix[no][i] == 1) && (!descoberto[i]) && (kSmallest[i]) ) 
					{
						descoberto[i] = true;
						fila.push_back(i);
					}
				}
			}

			//vetor de elementos S do Individual sendo criado
			vector<int> elementosIndividual;

			//adiciona elementos que tenham sido encontrados no grafo de suporte
			//ou seja, elementos conexos no grafo de suporte com raiz no tarefa da vez, j
			for (int i = 1; i <= n; i++) 
			{
				if (descoberto[i])
				{
					elementosIndividual.push_back(i);
				}
			}

			//calculates the Cut, based on S
			Individual indiv(inst,elementosIndividual);
			indiv.S.calculaYZ(sol);
			indiv.calculateOEC(sol, inst);
		
			//checks if set S is not already present in the population and appends the individual to the 
			insertUniqueIndividual(populacao, indiv);
		}
	}

	return populacao;
}

void elimina_desconexidade_S(conjuntoS &S, Solution& sol, int lider) 
{

	if (S.tamanho == 1) {return;}
	int p = 0;

	vector <bool> assignado(S.tamanhoMax+1);
	vector <int> minhoca;

	for (int i = 0; i < S.tamanhoMax+1; i++)
	{
		assignado[i] = false;
	}

	if (lider==-1) {
		lider = S.elementos[std::rand() % S.elementos.size()];
	}

	//realiza Breadth-First-Search para encontrar os elementos conexos e eliminar os desconexos depois
	vector<bool> descoberto;
	vector<int> fila;
	int contDescobertos;
	int i;
	int no;
	descoberto.resize(sol.n+1);

	descoberto[lider] = true;
	contDescobertos = 1;
	fila.push_back(lider);

	while ( fila.size()>0 ) {
		//le e deleta o primeiro elemento da fila
		no = fila[0];
		fila.erase( fila.begin() );
		for (i = 1; i <= sol.n; i++) {
			if ( (sol.adjMatrix[no][i] == 1) && (!descoberto[i]) ) {
				descoberto[i] = true;
				fila.push_back(i);
			}
		}
	}

	for (int i = S.elementos.size()-1; i > -1; i--)	{
		if (!descoberto[S.elementos[i]]) {
			S.excluiElemento(S.elementos[i]);
		}
	}
}

//Seleciona Populacao
void selecionaPopulacao(vector<Individual> &populacao, int tamanhoLimite)
{
	for (int i = 0; i < (int)populacao.size(); i++)
	{
		sort( populacao[i].S.elementos.begin(), populacao[i].S.elementos.end() );
	}
	sort (populacao.begin(), populacao.end(), lexicographical_compareInd);

	for (int i= (int)populacao.size()-1; i > 0; i--)
	{
		if ( populacao[i].equalS( populacao[i-1]) ) 
		{
			if (populacao[i].gap() > populacao[i-1].gap() )
			{
				populacao.erase (populacao.begin()+i);
			}
			else
			{
				populacao.erase (populacao.begin()+i-1);
			}
		}
	}

	if ((int)populacao.size() > tamanhoLimite) {
		sort(populacao.begin(), populacao.end());
		populacao.erase(populacao.begin()+tamanhoLimite,populacao.end());
	}	
}

// Crossover
Individual * crossover (Individual &pai, Individual &mae, Instance& inst, Solution& sol, vector<vector<bool> > conjuntoSbuscados)
{

	conjuntoS * S = new conjuntoS(inst);

	int i, raiz, no, destino;
	vector<int> fila;
	vector<int> precedente;
	vector<bool> descoberto;
	int contDescobertos;

	bool caminhoEncontrado = false;

	for (int i=0;i<inst.n;i++) {  //roda todos os elementos
		if (pai.S.pertenceS[i] && mae.S.pertenceS[i]) {  //verifica se o elemento pertence ao pai E a mae
			S->incluiElemento(i); //inclui o elemento em S
		} 
	}

	if (S->tamanho==0) { //verifica se os pais tem intersecao vazia
		//escolhe o menor caminho entre dois elementos aleatorios dos pais para incluir no filho
		precedente.resize(sol.n+1);
		descoberto.resize(sol.n+1);

		i = std::rand() % pai.S.elementos.size();
		raiz = pai.S.elementos[i];

		descoberto[raiz] = true;
		contDescobertos = 1;
		fila.push_back(raiz);

		while ( (fila.size()>0) && (!caminhoEncontrado) ) {
			//le e deleta o primeiro elemento da fila
			no = fila[0];
			fila.erase( fila.begin() ); 
			for (i = 1; i <= sol.n; i++) {
				if ( (sol.adjMatrix[no][i] == 1) && (!descoberto[i]) && (!caminhoEncontrado) ) {
					descoberto[i] = true;
					fila.push_back(i);
					precedente[i] = no;
					if (mae.S.pertenceS[i]) {
						caminhoEncontrado = true;
						destino = i;
					}
				}
			}
		}

		//refaz o caminho do elemento da mae para o do pai,
		// incluindo os elementos visitados no filho
		i = destino;
		S->incluiElemento(i);
		while (precedente[i] != 0) {
			i = precedente[i];
			S->incluiElemento(i);
		}
	}

	//seleciona um elemento de S inicial que pertena a ambos os parentes
	int lider = S->elementos[std::rand() % (int)S->elementos.size()];

	for (int i=0;i<inst.n;i++) { //roda todos os elementos
		if (!S->pertenceS[i] ) { //verifica se o elemento ja nao pertence ao conjunto S
			if (pai.S.pertenceS[i] != mae.S.pertenceS[i]) { //verifica se o elemento pertence ao pai OU a mae
				if (std::rand() % 2 == 0) S->incluiElemento(i); //inclui o elemento em S com 50% de chance
			}
		}
	}

	if (crossoverConexo) elimina_desconexidade_S(*S, sol, lider);

	Individual * filho = new Individual(inst, S->elementos);
	filho->S.calculaYZ(sol);
	filho->calculateOEC(sol,inst);
		
	delete S;
	
	return filho;
}

//Calculo da Diversidade
double calculaDiversidade(vector<Individual> &populacao, int nIndividuals) 
{
	if ( (nIndividuals == -1) || (nIndividuals > (int)populacao.size()) )
		nIndividuals = populacao.size();
	
	if (nIndividuals>1){
		double distancia=0;
		int n=0;
		for (int i = 0; i < nIndividuals-1; i++) 
		{
			for (int j = i+1; j<nIndividuals; j++) 
			{
				distancia += populacao[i].calculaDistancia(populacao[j]);
				n++;
			}
		}
		return distancia/n;
	} else
	{
		return 0;
	}
}

void buscaLocalOEC(Instance& inst, Individual indiv, Solution& sol, vector<Individual> &violados, 
			vector<vector< bool > >& conjuntoSbuscados, int level, int tabu, double previousBestGap) {
	/*if (conjuntoSbuscado(conjuntoSbuscados, indiv.S.pertenceS, true)) 
	{
		return;
	}*/

	bool hasImprovement = true;

	vector <int> elementos(inst.n);
	for (int i=0;i<inst.n;i++) {
		elementos[i] = i+1;
	}
						
	while (hasImprovement)
	{	
		double bestImprov = -0.001; 
		int i_melhor = -1;
		std::random_shuffle (elementos.begin(), elementos.end());
		for (int ii = 0; ii < (int)elementos.size(); ii++) 
		{
			int i = elementos[ii]; 
			if (indiv.S.pertenceS[i]) 
			{
				if (indiv.S.tamanho>1) 
				{ //se S tiver mais que 1 elemento						
					double improv = indiv.evaluateRemovalOEC(sol, inst, i);

					if (improv < bestImprov - 0.001)
					{
						bestImprov = improv; 
						i_melhor = i;
						double bestGap = indiv.gap() + improv;

						if (bestGap < gapRelevante) 
						{		
							Individual violatedIndiv = indiv;
							violatedIndiv.S.excluiElemento(i);
							violatedIndiv.S.calculaYZ_removal(sol, i);
							violatedIndiv.calculateOEC(sol,inst);
							verifica_novo_Individual_completo(violados, violatedIndiv);
						}
					}
				}
			} 
			else 
			{ //se nao pertencer ao conjunto S
				bool conexo = true;
				if (buscaConexa)
				{
					conexo = false;
					for (int k = 0; k < (int)sol.entra[i].size(); k++)
					{
						if (indiv.S.pertenceS[sol.arcs[sol.entra[i][k]].i])
						{
							conexo = true;
							break;
						}
					}
					if (!conexo)
					{
						for (int k = 0; k < (int)sol.sai[i].size(); k++)
						{
							if (indiv.S.pertenceS[sol.arcs[sol.sai[i][k]].j])
							{
								conexo = true;
								break;
							}
						}
					}
				} 

				if (conexo) 
				{			
					double improv = indiv.evaluateInsertionOEC(sol, inst, i);

					if (improv < bestImprov - 0.001)
					{
						bestImprov = improv; 
						i_melhor = i;
						double bestGap = indiv.gap() + improv;
					
						if (bestGap < gapRelevante) 
						{		
							Individual violatedIndiv = indiv;
							violatedIndiv.S.incluiElemento(i);
							violatedIndiv.S.calculaYZ_insertion(sol, i);
							violatedIndiv.calculateOEC(sol,inst);
							verifica_novo_Individual_completo(violados, violatedIndiv);
				
						}
					}					
				}
			}	
			if (i_melhor != -1) break;
		}

		if (i_melhor != -1)
		{
			if (indiv.S.pertenceS[i_melhor])
			{
				indiv.S.excluiElemento(i_melhor);
				indiv.S.calculaYZ_removal(sol, i_melhor);
			}
			else
			{
				indiv.S.incluiElemento(i_melhor);
				indiv.S.calculaYZ_insertion(sol, i_melhor);
			}
			indiv.calculateOEC(sol,inst);
		}
		else
		{
			hasImprovement = false;
		}
	}
}

bool conjuntoSbuscado(vector<vector<bool> > &conjuntoSbuscados, vector<bool> &conjuntoSbool, bool registrar)
{
	for (int i = 0; i < (int)conjuntoSbuscados.size(); i++)
	{
		bool diff = false;
		for (int j = 0; j < (int)conjuntoSbool.size(); j++)
		{
			if (conjuntoSbuscados[i][j] != conjuntoSbool[j])
			{
				diff = true;
				break;
			}
		}
		if (!diff)
		{
			return true;
		}
	}

	if (registrar)
		conjuntoSbuscados.push_back(conjuntoSbool);

	return false;
}

//adiciona o novo Individual ao vetor de Individuals criados, caso ele ja no existe no mesmo
//evita a presenca de duplicatas no vetor de Individuals criados
 bool insertUniqueIndividual(vector<Individual> &population, Individual &newIndividual) 
{
	 for (int i = 0; i < (int)population.size(); i++) 
	 {
		 if (population[i].conjuntoSigual(newIndividual)) 
		 {
			return false;
		 }
	 }
	 population.push_back(newIndividual);
	 return true;
 }

bool verifica_novo_Individual(vector<Individual> &gerados, string &impressaoS) 
 {
	 for (int i = 0; i < (int)gerados.size(); i++) {
		 if (gerados[i].assinatura == impressaoS) {
			return false;
		 }
	 }
	 return true;
 }

bool verifica_novo_Individual_completo(vector<Individual> &gerados, Individual &novo_Individual)
{
	 //novo_Individual.buscaAssinatura();
	 for (int i = 0; i < (int)gerados.size(); i++) {
		 if (gerados[i] == novo_Individual) {
			return false;
		 }
	 }
	 gerados.push_back(Individual(novo_Individual));
	 return true;
 }

//sets t, lhs, rhs by exploring S.pTotal, S.Y_vec and S.Z_vec	
void Individual::calculateOEC(Solution& sol, Instance&  inst) 
{
	int melhor_t = 1;
	double melhor_lhs = 0;
	double melhor_rhs = 0;

	
	#ifndef REVERSE_OEC
	CalculateOEC(S.pTotal, S.Y_vec, S.Z_vec, sol, inst,
				  melhor_t,  melhor_lhs,  melhor_rhs);
#else
	CalculateRevOEC(S.pTotal, S.Y_vec, S.Z_vec, sol, inst,
				  melhor_t,  melhor_lhs,  melhor_rhs);
#endif

	t = melhor_t;
	corte.lhs = melhor_lhs;
	corte.rhs = melhor_rhs;
}

//sets t, lhs, rhs by exploring S.pTotal, S.Y_vec and S.Z_vec	
double Individual::evaluateInsertionOEC(Solution& sol, Instance&  inst, int newJob) 
{
	int melhor_t = 1;
	double melhor_lhs = 0;
	double melhor_rhs = 0;

	int new_pTotal = S.pTotal + inst.p[newJob];
	vector<double> new_Y_vec = S.Y_vec;
	vector<double> new_Z_vec = S.Z_vec;

	//for all variables representing flow going into newJob
	for (int j = 0; j < (int)sol.entra[newJob].size(); j++) 
	{
		ArcVariable& var = sol.arcs[sol.entra[newJob][j]]; 
		if (!S.pertenceS[var.i]) //Delta-
		{  
			new_Z_vec[var.t] += var.value;
		}
		else //was in Delta+
		{
			new_Y_vec[var.t] -= var.value;
		}
	}

	//for all variables representing flow going out of newJob
	for (int j = 0; j < (int)sol.sai[newJob].size(); j++)
	{
		ArcVariable& var = sol.arcs[sol.sai[newJob][j]]; 
		if (!S.pertenceS[var.j])  //Delta+
		{  
			new_Y_vec[var.t] += var.value;
		}
		else //was in Delta-
		{
			new_Z_vec[var.t] -= var.value;
		}
	}

	#ifndef REVERSE_OEC
	CalculateOEC(new_pTotal, new_Y_vec, new_Z_vec, sol, inst,
				  melhor_t,  melhor_lhs,  melhor_rhs);
	#else
		CalculateRevOEC(new_pTotal, new_Y_vec, new_Z_vec, sol, inst,
					  melhor_t,  melhor_lhs,  melhor_rhs);
	#endif
	
	//violation difference (new_violation - old_violation)
	//if negative, movement violates more
	return (melhor_lhs - melhor_rhs) - (corte.lhs-corte.rhs);
}

//sets t, lhs, rhs by exploring S.pTotal, S.Y_vec and S.Z_vec	
double Individual::evaluateRemovalOEC(Solution& sol, Instance&  inst, int oldJob) 
{
	int melhor_t = 1;
	double melhor_lhs = 0;
	double melhor_rhs = 0;

	int new_pTotal = S.pTotal - inst.p[oldJob];
	vector<double> new_Y_vec = S.Y_vec;
	vector<double> new_Z_vec = S.Z_vec;

	//for all variables representing flow going into newJob
		for (int j = 0; j < (int)sol.entra[oldJob].size(); j++) 
		{
			ArcVariable& var = sol.arcs[sol.entra[oldJob][j]]; 
			if (!S.pertenceS[var.i]) //Delta-
			{  
				new_Z_vec[var.t] -= var.value;
			}
			else //was in Delta+
			{
				new_Y_vec[var.t] += var.value;
			}
		}

		//for all variables representing flow going out of newJob
		for (int j = 0; j < (int)sol.sai[oldJob].size(); j++)
		{
			ArcVariable& var = sol.arcs[sol.sai[oldJob][j]]; 
			if (!S.pertenceS[var.j])  //Delta+
			{  
				new_Y_vec[var.t] -= var.value;
			}
			else //was in Delta-
			{
				new_Z_vec[var.t] += var.value;
			}
		}

	#ifndef REVERSE_OEC
	CalculateOEC(new_pTotal, new_Y_vec, new_Z_vec, sol, inst,
					melhor_t,  melhor_lhs,  melhor_rhs);
	#else
	CalculateRevOEC(new_pTotal, new_Y_vec, new_Z_vec, sol, inst,
					melhor_t,  melhor_lhs,  melhor_rhs);
	#endif
	
	//violation difference (new_violation - old_violation)
	//if negative, movement violates more
	return (melhor_lhs - melhor_rhs) - (corte.lhs-corte.rhs);
}

void CalculateOEC(int pTotal, vector<double>& Y_vec, vector<double>& Z_vec, Solution& sol, Instance&  inst,
				  int& t, double& lhs, double& rhs) 
{			
	rhs = 2; 
	int tempo = 1;
	
	double newlhs = 0;

	int last_t1 = 0;
	int last_tz = 0;
		
	int t1 = pTotal - tempo - (inst.m-2)*(tempo-1);
	if (t1 > sol.T) 
	{
		t1 = sol.T;
	}
	int t2 = sol.T - pTotal + inst.m*(tempo-1)+1;
	int tz = t2 > t1 ? t2 : t1;

	//Z
	for (int q = tz; q <= sol.T; q++)
		newlhs -= Z_vec[q];

	//Y
	for (int q = tempo; q <= t1; q++)
		newlhs += Y_vec[q];
		
	for (int q = t1+1; q <= sol.T; q++)
		newlhs += 2*Y_vec[q];
		
	t = tempo;
	lhs = newlhs;	

	last_t1 = t1;
	last_tz = tz;
	
	for (tempo = 2; tempo <= (pTotal-1)/inst.m +1; tempo++)
	{
		int t1 = pTotal - tempo - (inst.m-2)*(tempo-1);
		if (t1 > sol.T) 
			t1 = sol.T;
		int t2 = sol.T - pTotal + inst.m*(tempo-1) + 1;
		int tz = t2 > t1 ? t2 : t1;

		//Z
		if (tz > last_tz)
		{
			for (int t = last_tz; t < tz; t++)				
				newlhs += Z_vec[t];				
		}
		if (tz < last_tz)
		{
			for (int t = tz; t < last_tz; t++)
				newlhs -= Z_vec[t];
		}
			
		//Y
		newlhs -= Y_vec[tempo-1];
			
		for (int q = last_t1; q > t1; q--)
		{
			newlhs += Y_vec[q];
		}

		// <= used instead of < to always have last t
		if (newlhs <= lhs)
		{
			lhs = newlhs;
			t = tempo;
		}
			
		last_t1 = t1;
		last_tz = tz;
	}
}

string imprimeS(vector<int> S) 
{	
	int i;
	string conjunto;
	int n = S.size();

	std::sort(S.begin(),S.end());

	conjunto = "";

	for (i=0;i<n;i++){
		conjunto = conjunto + "[" + to_string(S[i]) + "]";
	}

	return conjunto;
}